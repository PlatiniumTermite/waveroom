<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>WaveRoom â€” Sync Audio</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#07090f;--panel:#0e1118;--border:#1a1f2e;
  --cyan:#00e5ff;--green:#00ff88;--orange:#ff7b35;--red:#ff4466;
  --text:#e8eaf0;--muted:#5a6070;--white:#fff;
  --r:8px;
}
body{
  background:var(--bg);color:var(--text);
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
  min-height:100vh;display:flex;align-items:center;justify-content:center;
  padding:16px;
}
.app{width:100%;max-width:420px}

/* SCREENS */
.screen{display:none}
.screen.on{display:block}

/* CARD */
.card{
  background:var(--panel);border:1px solid var(--border);
  border-radius:14px;padding:24px;margin-bottom:12px;
}

/* LOGO */
.logo{
  font-size:26px;font-weight:900;letter-spacing:-1px;
  background:linear-gradient(135deg,var(--cyan),var(--green));
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  margin-bottom:4px;
}
.logo-sub{font-size:11px;color:var(--muted);font-family:'Courier New',monospace;margin-bottom:24px}

/* INPUTS */
.inp{
  width:100%;background:#0a0d14;border:1px solid var(--border);
  border-radius:var(--r);padding:13px 14px;color:var(--text);
  font-size:15px;outline:none;transition:.15s;margin-bottom:10px;
}
.inp:focus{border-color:var(--cyan);box-shadow:0 0 0 3px rgba(0,229,255,.08)}
.inp::placeholder{color:var(--muted)}
#join-inp{
  text-align:center;letter-spacing:8px;font-size:22px;
  font-family:'Courier New',monospace;font-weight:700;text-transform:uppercase;
}

/* BUTTONS */
.btn{
  width:100%;padding:13px;border-radius:var(--r);border:none;
  font-weight:700;font-size:14px;cursor:pointer;transition:.15s;
  letter-spacing:.3px;
}
.btn:disabled{opacity:.4;cursor:not-allowed}
.btn-cyan{background:linear-gradient(135deg,var(--cyan),#00b4cc);color:#000}
.btn-green{background:linear-gradient(135deg,var(--green),#00cc6a);color:#000}
.btn-red{background:var(--red);color:#fff}
.btn-ghost{background:transparent;border:1px solid var(--border);color:var(--muted)}
.btn-orange{background:var(--orange);color:#000}
.btn + .btn{margin-top:8px}

/* STATUS ROW */
.srow{display:flex;align-items:center;gap:8px;margin-bottom:16px}
.dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.dot-live{background:var(--red);box-shadow:0 0 8px var(--red);animation:pulse 1.2s infinite}
.dot-sync{background:var(--green);box-shadow:0 0 8px var(--green)}
.dot-wait{background:var(--muted)}
.dot-conn{background:var(--cyan)}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}

/* CODE DISPLAY */
.code-box{
  background:#0a0d14;border:1px solid var(--border);border-radius:var(--r);
  padding:14px;text-align:center;margin-bottom:12px;cursor:pointer;
}
.code-val{
  font-family:'Courier New',monospace;font-size:32px;font-weight:900;
  letter-spacing:8px;color:var(--cyan);
}
.code-hint{font-size:10px;color:var(--muted);margin-top:4px}

/* VISUALIZER */
canvas{width:100%;height:52px;border-radius:var(--r);display:block;background:#05060a}

/* STATS */
.stats{display:flex;gap:8px;margin-top:10px}
.stat{flex:1;background:#0a0d14;border-radius:6px;padding:8px;text-align:center}
.stat-val{font-size:13px;font-weight:700;font-family:'Courier New',monospace;color:var(--cyan)}
.stat-lbl{font-size:9px;color:var(--muted);text-transform:uppercase;margin-top:2px}

/* LISTENER COUNT */
.lcnt{font-size:28px;font-weight:900;color:var(--green);text-align:center}
.lcnt-lbl{font-size:10px;color:var(--muted);text-align:center}

/* SHARE STEPS */
.steps{margin:12px 0}
.step{
  display:flex;gap:10px;align-items:flex-start;
  padding:9px 0;border-bottom:1px solid var(--border);font-size:13px;
}
.step:last-child{border-bottom:none}
.step-n{
  background:linear-gradient(135deg,var(--cyan),var(--green));color:#000;
  width:22px;height:22px;border-radius:50%;display:flex;align-items:center;
  justify-content:center;font-weight:900;font-size:11px;flex-shrink:0;
}

/* SECTION TITLE */
.stitle{font-size:10px;font-weight:700;letter-spacing:1px;color:var(--muted);
  text-transform:uppercase;margin-bottom:10px}

/* ERROR */
.err{
  background:rgba(255,68,102,.08);border:1px solid rgba(255,68,102,.25);
  border-radius:var(--r);padding:10px 12px;font-size:13px;color:var(--red);
  display:none;margin-top:8px;
}
.err.on{display:block}

/* TOAST */
.toast{
  position:fixed;bottom:24px;left:50%;transform:translateX(-50%) translateY(80px);
  background:#1a1f2e;border:1px solid var(--border);border-radius:20px;
  padding:10px 20px;font-size:13px;font-weight:600;
  transition:transform .3s;pointer-events:none;z-index:999;white-space:nowrap;
}
.toast.on{transform:translateX(-50%) translateY(0)}

/* TAP OVERLAY */
#tap-overlay{
  display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);
  z-index:100;align-items:center;justify-content:center;flex-direction:column;gap:16px;
}
#tap-overlay.on{display:flex}
#tap-overlay .big{font-size:48px}
#tap-overlay p{font-size:17px;font-weight:700;color:var(--white)}
#tap-overlay small{font-size:13px;color:var(--muted);text-align:center;padding:0 32px}

/* VOLUME */
.vol-row{display:flex;align-items:center;gap:10px;margin-top:10px}
.vol-row input[type=range]{flex:1;accent-color:var(--cyan)}
.vol-val{font-size:12px;font-family:'Courier New',monospace;color:var(--cyan);min-width:36px;text-align:right}

/* CONN BADGE */
.conn{font-size:10px;font-family:'Courier New',monospace;display:flex;align-items:center;gap:5px}

/* WAVEFORM LIVE BARS */
.wavebars{display:flex;align-items:center;gap:3px;height:24px}
.wb{width:3px;border-radius:2px;background:var(--red);animation:wave var(--d,.6s) ease-in-out infinite alternate}
.wb:nth-child(1){--d:.5s;height:40%}
.wb:nth-child(2){--d:.7s;height:90%}
.wb:nth-child(3){--d:.4s;height:60%}
.wb:nth-child(4){--d:.8s;height:100%}
.wb:nth-child(5){--d:.6s;height:50%}
@keyframes wave{to{height:20%}}

/* QUALITY BADGES */
.badge{display:inline-block;padding:2px 7px;border-radius:4px;font-size:9px;
  font-weight:700;letter-spacing:.5px;font-family:'Courier New',monospace}
.badge-live{background:rgba(255,68,102,.15);color:var(--red);border:1px solid rgba(255,68,102,.3)}
.badge-sync{background:rgba(0,255,136,.1);color:var(--green);border:1px solid rgba(0,255,136,.25)}

hr{border:none;border-top:1px solid var(--border);margin:14px 0}
</style>
</head>
<body>
<div class="app">

<!-- â•â•â• HOME â•â•â• -->
<div class="screen on" id="s-home">
  <div class="card">
    <div class="logo">WaveRoom</div>
    <div class="logo-sub">// multi-device audio sync</div>

    <div class="stitle">Create a Room</div>
    <input class="inp" id="room-name" placeholder="Room name (optional)" maxlength="40">
    <button class="btn btn-cyan" onclick="createRoom()">Create Room â†’</button>

    <hr>

    <div class="stitle">Join a Room</div>
    <input class="inp" id="join-inp" placeholder="ABC123" maxlength="6" inputmode="text" autocomplete="off" spellcheck="false">
    <button class="btn btn-green" onclick="joinRoom()">Join Room â†’</button>
    <div class="err" id="join-err">Room not found. Check the code.</div>
  </div>

  <div class="card" style="padding:12px 16px">
    <div class="conn" id="conn-row">
      <div class="dot dot-wait" id="conn-dot"></div>
      <span id="conn-txt">Connecting...</span>
    </div>
  </div>
</div>

<!-- â•â•â• HOST â•â•â• -->
<div class="screen" id="s-host">
  <div class="card">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
      <div>
        <div class="logo" style="font-size:20px">WaveRoom</div>
        <div id="h-room-name" style="font-size:12px;color:var(--muted)">Host</div>
      </div>
      <div id="h-status-row" class="srow" style="margin:0">
        <div class="dot dot-wait" id="h-dot"></div>
        <span id="h-status" style="font-size:12px">Ready</span>
      </div>
    </div>

    <!-- Room code -->
    <div class="code-box" onclick="copyCode()" title="Tap to copy">
      <div class="code-val" id="h-code">------</div>
      <div class="code-hint">ğŸ“‹ Tap to copy â€” share this code with listeners</div>
    </div>

    <!-- Listener count -->
    <div style="text-align:center;margin-bottom:14px">
      <div class="lcnt" id="h-lcnt">0</div>
      <div class="lcnt-lbl">Listeners connected</div>
    </div>

    <!-- How to share -->
    <div class="stitle">How to share audio</div>
    <div class="steps">
      <div class="step"><div class="step-n">1</div><div>Open the video or music you want to share in <b>another tab/app</b></div></div>
      <div class="step"><div class="step-n">2</div><div>Tap <b>Start Sharing</b> below â†’ choose that tab â†’ tick <b style="color:var(--orange)">"Share tab audio"</b></div></div>
      <div class="step"><div class="step-n">3</div><div>Listeners hear audio only â€” perfectly synced on all their devices</div></div>
    </div>

    <div id="h-live-indicator" style="display:none;margin-bottom:12px">
      <div class="srow">
        <div class="dot dot-live"></div>
        <span style="font-size:13px;font-weight:700">LIVE â€” listeners are hearing your audio</span>
        <div class="wavebars" style="margin-left:auto">
          <div class="wb"></div><div class="wb"></div><div class="wb"></div>
          <div class="wb"></div><div class="wb"></div>
        </div>
      </div>
      <canvas id="h-viz" style="margin-top:8px"></canvas>
    </div>

    <button class="btn btn-orange" id="h-start-btn" onclick="startShare()">ğŸ™ Start Sharing</button>
    <button class="btn btn-red"    id="h-stop-btn"  onclick="stopShare()" style="display:none">â¹ Stop Sharing</button>
    <button class="btn btn-ghost"  onclick="leave()" style="margin-top:8px">â† Leave Room</button>
  </div>
</div>

<!-- â•â•â• LISTENER â•â•â• -->
<div class="screen" id="s-listen">
  <div class="card">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
      <div>
        <div class="logo" style="font-size:20px">WaveRoom</div>
        <div id="l-room-name" style="font-size:12px;color:var(--muted)">Listener</div>
      </div>
      <div id="l-status-row" class="srow" style="margin:0">
        <div class="dot dot-wait" id="l-dot"></div>
        <span id="l-status" style="font-size:12px">Waiting...</span>
      </div>
    </div>

    <!-- Waiting state -->
    <div id="l-waiting" style="text-align:center;padding:20px 0;color:var(--muted)">
      <div style="font-size:36px;margin-bottom:8px">ğŸ§</div>
      <div style="font-size:14px">Waiting for host to start audio...</div>
    </div>

    <!-- Live state -->
    <div id="l-live" style="display:none">
      <div class="srow">
        <div class="dot dot-live"></div>
        <span style="font-size:13px;font-weight:700">Live Audio</span>
        <span class="badge badge-sync" style="margin-left:auto" id="l-sync-badge">syncing...</span>
      </div>
      <canvas id="l-viz" style="margin:10px 0"></canvas>
    </div>

    <!-- Volume -->
    <div class="vol-row">
      <span style="font-size:13px">ğŸ”Š</span>
      <input type="range" min="0" max="1" step="0.01" value="0.9" id="l-vol" oninput="setListenerVol(this.value)">
      <span class="vol-val" id="l-vol-val">90%</span>
    </div>

    <!-- Stats -->
    <div class="stats" id="l-stats" style="display:none">
      <div class="stat"><div class="stat-val" id="l-lag">â€”</div><div class="stat-lbl">Latency</div></div>
      <div class="stat"><div class="stat-val" id="l-drift">â€”</div><div class="stat-lbl">Drift</div></div>
      <div class="stat"><div class="stat-val" id="l-buf">â€”</div><div class="stat-lbl">Buffer</div></div>
    </div>

    <button class="btn btn-ghost" onclick="leave()" style="margin-top:14px">â† Leave Room</button>
  </div>
</div>

</div><!-- .app -->

<!-- TAP TO PLAY OVERLAY -->
<div id="tap-overlay" onclick="tapToPlay()">
  <div class="big">ğŸ”Š</div>
  <p>Tap to hear audio</p>
  <small>Browser requires a tap before playing audio</small>
</div>

<div id="toast" class="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WAVEROOM v4 â€” Audio-only multi-device sync
//
// Architecture:
//   HOST: getDisplayMedia â†’ MediaRecorder(opus 80ms chunks) â†’ socket
//   SERVER: relay chunks with timestamps
//   LISTENER: MediaSource â†’ AudioContext â†’ Web Audio API playback
//
// Sync method:
//   1. NTP clock sync (12 rounds) â†’ accurate clockOffset
//   2. Server timestamps each chunk
//   3. Listener schedules AudioContext.currentTime playback
//      so all devices play the same chunk at the same moment
//
// This is how professional broadcast sync works.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const NTP_ROUNDS  = 16;        // more rounds = more accurate
const CHUNK_MS    = 60;        // ms per MediaRecorder chunk (lower = less lag)
const TARGET_LAG  = 400;       // ms behind live (buffer for jitter). Lower = less lag but more glitches
const DRIFT_MAX   = 0.08;      // seconds of allowed drift before correction

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let sock = null;
let roomCode = null;
let amHost = false;

// NTP
let ntpSamples = [];
let clockOffset = 0;   // local = server + clockOffset  â†’  server = local - clockOffset
let ntpDone = false;

// Host side
let captureStream  = null;
let mediaRecorder  = null;
let hostAudioCtx   = null;
let hostAnalyser   = null;
let hostVizRaf     = null;
let chunkSeq       = 0;

// Listener side â€” Web Audio API based playback
let listenerAudioCtx  = null;   // AudioContext â€” its clock is THE sync reference
let listenerGain      = null;   // GainNode for volume
let listenerAnalyser  = null;   // for visualizer
let listenerVizRaf    = null;
let streamStartSrvTime = null;  // server Date.now() when stream started
let streamStartAcTime  = null;  // AudioContext.currentTime when stream started
let chunkQueue        = [];     // { seq, data:ArrayBuffer, srvTs } waiting to decode
let nextSeq           = 0;
let decoding          = false;
let listenerRunning   = false;
let statsRaf          = null;

// â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const G = id => document.getElementById(id);
function srvNow() { return Date.now() - clockOffset; }

function toast(msg, dur = 3000) {
  const t = G('toast');
  t.textContent = msg;
  t.classList.add('on');
  clearTimeout(t._t);
  t._t = setTimeout(() => t.classList.remove('on'), dur);
}

function show(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('on'));
  G(id).classList.add('on');
}

function setStatus(dotId, txtId, dotClass, txt) {
  const d = G(dotId), t = G(txtId);
  if (d) d.className = 'dot ' + dotClass;
  if (t) t.textContent = txt;
}

function setConn(on) {
  G('conn-dot').className = 'dot ' + (on ? 'dot-conn' : 'dot-wait');
  G('conn-txt').textContent = on ? 'Online' : 'Connecting...';
}

function copyCode() {
  const code = G('h-code').textContent;
  navigator.clipboard?.writeText(code).then(() => toast('ğŸ“‹ Copied: ' + code));
}

// â”€â”€ NTP CLOCK SYNC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Measures the offset between local clock and server clock.
// After NTP, clockOffset = (local - server)
// So server time = Date.now() - clockOffset
// And srvNow() gives us server wall time from local machine.

function startNTP() {
  ntpSamples = [];
  ntpDone = false;
  sendNTPPing();
}

function sendNTPPing() {
  if (!sock || !sock.connected) return;
  sock.emit('ntp:ping', { clientTime: Date.now() });
}

function onNTPPong({ clientTime, serverTime }) {
  const now = Date.now();
  const rtt = now - clientTime;
  const offset = now - (serverTime + rtt / 2);  // local - server
  ntpSamples.push({ rtt, offset });

  if (ntpSamples.length < NTP_ROUNDS) {
    setTimeout(sendNTPPing, 30);
  } else {
    // Use median of best-RTT third for accuracy
    ntpSamples.sort((a, b) => a.rtt - b.rtt);
    const best = ntpSamples.slice(0, Math.ceil(NTP_ROUNDS / 3));
    clockOffset = best.reduce((s, x) => s + x.offset, 0) / best.length;
    ntpDone = true;
    const rttMs = ntpSamples[0].rtt;
    console.log(`[NTP] done. offset=${clockOffset.toFixed(1)}ms bestRTT=${rttMs}ms`);
  }
}

// â”€â”€ SOCKET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initSock() {
  if (sock && sock.connected) return;
  sock = io({
    transports: ['websocket', 'polling'],
    reconnectionAttempts: 30,
    reconnectionDelay: 1000,
    timeout: 20000,
  });

  sock.on('connect', () => {
    console.log('[WS] connected', sock.id);
    setConn(true);
    startNTP();
    clearInterval(window._ka);
    window._ka = setInterval(() => {
      if (sock?.connected) sock.emit('keepalive');
    }, 15000);
  });

  sock.on('disconnect', () => {
    setConn(false);
    if (roomCode) toast('âš ï¸ Reconnecting...');
  });

  sock.on('reconnect', () => {
    setConn(true);
    startNTP();
    if (roomCode && !amHost) {
      // Listener reconnected â€” reinitialise audio context
      toast('âœ… Reconnected');
    }
  });

  sock.on('connect_error', () => setConn(false));
  sock.on('ntp:pong', onNTPPong);

  // â”€â”€ HOST events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sock.on('listener:joined', ({ id, count }) => {
    G('h-lcnt').textContent = count;
    toast('ğŸ§ Listener joined! (' + count + ' total)');
  });

  sock.on('listener:left', ({ id, count }) => {
    G('h-lcnt').textContent = count;
  });

  // â”€â”€ LISTENER events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sock.on('stream:start', ({ mime, serverTime }) => {
    console.log('[L] stream:start mime=' + mime);
    startListening(mime, serverTime);
  });

  sock.on('stream:chunk', ({ seq, data, ts }) => {
    if (!listenerRunning) return;
    // data arrives as ArrayBuffer (socket.io binary)
    const ab = data instanceof ArrayBuffer ? data
              : data?.buffer ? data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength)
              : null;
    if (!ab) { console.warn('[L] bad chunk type', typeof data); return; }
    chunkQueue.push({ seq, data: ab, srvTs: ts });
    drainQueue();
  });

  sock.on('stream:stop', () => {
    console.log('[L] stream:stop');
    stopListening();
    toast('Host stopped the stream');
  });

  sock.on('host:left', () => {
    toast('ğŸšª Host ended the session');
    setTimeout(leave, 1500);
  });
}

// â”€â”€ CREATE / JOIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createRoom() {
  const name = G('room-name').value.trim() || 'Audio Room';
  const btn = document.querySelector('#s-home .btn-cyan');
  btn.disabled = true; btn.textContent = 'Creating...';
  amHost = true; initSock();

  const go = () => sock.emit('room:create', { name }, res => {
    btn.disabled = false; btn.textContent = 'Create Room â†’';
    if (!res?.ok) { toast('âŒ Could not create room'); return; }
    roomCode = res.code;
    G('h-code').textContent = res.code;
    G('h-room-name').textContent = res.name;
    show('s-host');
    toast('ğŸ‰ Room created! Share: ' + res.code);
  });

  if (sock.connected) go();
  else {
    let done = false;
    sock.once('connect', () => { done = true; setTimeout(go, 200); });
    setTimeout(() => { if (!done) { btn.disabled = false; btn.textContent = 'Create Room â†’'; toast('âŒ Cannot connect'); } }, 8000);
  }
}

async function joinRoom() {
  const code = G('join-inp').value.trim().toUpperCase().replace(/[^A-Z0-9]/g, '');
  if (code.length < 6) { toast('Enter the 6-letter room code'); return; }

  const btn = document.querySelector('#s-home .btn-green');
  btn.disabled = true; btn.textContent = 'Joining...';
  G('join-err').classList.remove('on');

  // HTTP pre-check
  try {
    const r = await fetch('/room/' + code);
    const d = await r.json();
    if (!d.exists) {
      G('join-err').textContent = 'Room "' + code + '" not found. Check the code or ask the host to recreate.';
      G('join-err').classList.add('on');
      btn.disabled = false; btn.textContent = 'Join Room â†’';
      return;
    }
  } catch (e) { /* server might just be loading, try socket anyway */ }

  amHost = false; initSock();

  const go = () => sock.emit('room:join', { code }, res => {
    btn.disabled = false; btn.textContent = 'Join Room â†’';
    if (!res?.ok) {
      G('join-err').textContent = 'Room not found. Host may have left.';
      G('join-err').classList.add('on');
      return;
    }
    roomCode = code;
    G('l-room-name').textContent = res.name + ' Â· ' + code;
    show('s-listen');
    toast('ğŸ§ Joined "' + res.name + '"!');

    // If stream already running when we joined â€” start listening immediately
    if (res.streaming) {
      // We'll get stream:start shortly or handle via resync
      toast('ğŸ”´ Stream is live â€” connecting...');
    }
  });

  if (sock.connected) go();
  else {
    let done = false;
    sock.once('connect', () => { done = true; setTimeout(go, 200); });
    setTimeout(() => {
      if (!done) {
        btn.disabled = false; btn.textContent = 'Join Room â†’';
        G('join-err').textContent = 'Cannot connect. Check internet.';
        G('join-err').classList.add('on');
      }
    }, 8000);
  }
}

// â”€â”€ SCREEN SHARE (HOST) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function startShare() {
  try {
    // getDisplayMedia â€” user picks a tab or screen
    // Chrome shows "Share tab audio" checkbox when video is requested
    captureStream = await navigator.mediaDevices.getDisplayMedia({
      video: { width: 1, height: 1, frameRate: 1 }, // minimal â€” just to get audio checkbox
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: 48000,
        channelCount: 2,
      }
    });

    const audioTracks = captureStream.getAudioTracks();
    if (!audioTracks.length) {
      captureStream.getTracks().forEach(t => t.stop());
      toast('âŒ No audio! Make sure to tick "Share tab audio"', 6000);
      return;
    }

    // Kill video track â€” we only want audio
    captureStream.getVideoTracks().forEach(t => t.stop());

    // Build audio-only stream for MediaRecorder
    const audioOnlyStream = new MediaStream(audioTracks);

    // Pick best mime type
    const mime = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus']
      .find(m => MediaRecorder.isTypeSupported(m)) || '';

    // Host visualizer
    hostAudioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
    const src = hostAudioCtx.createMediaStreamSource(audioOnlyStream);
    hostAnalyser = hostAudioCtx.createAnalyser(); hostAnalyser.fftSize = 512;
    src.connect(hostAnalyser);
    G('h-live-indicator').style.display = 'block';
    startViz('h-viz', hostAnalyser, hostVizRaf, raf => hostVizRaf = raf);

    // MediaRecorder â€” encode to opus chunks
    mediaRecorder = new MediaRecorder(audioOnlyStream, { mimeType: mime, audioBitsPerSecond: 128000 });
    chunkSeq = 0;

    mediaRecorder.ondataavailable = async e => {
      if (!e.data || e.data.size === 0 || !sock?.connected) return;
      const buf = await e.data.arrayBuffer();
      sock.emit('stream:chunk', { seq: chunkSeq++, data: buf });
    };

    // Tell server we're starting
    sock.emit('stream:start', { mime });
    mediaRecorder.start(CHUNK_MS);

    G('h-start-btn').style.display = 'none';
    G('h-stop-btn').style.display = '';
    setStatus('h-dot', 'h-status', 'dot-live', 'ğŸ”´ Live');
    toast('ğŸ”´ Live! Listeners can hear your audio');

    // Handle user stopping via browser's built-in stop button
    audioTracks[0].onended = () => stopShare();

  } catch (e) {
    if (e.name === 'NotAllowedError') toast('âŒ Permission denied', 5000);
    else toast('âŒ ' + e.message, 5000);
    console.error('[SHARE]', e);
  }
}

function stopShare() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    try { mediaRecorder.stop(); } catch (e) {}
  }
  if (captureStream) {
    captureStream.getTracks().forEach(t => t.stop());
    captureStream = null;
  }
  if (hostAudioCtx) { hostAudioCtx.close().catch(() => {}); hostAudioCtx = null; }
  if (hostVizRaf) { cancelAnimationFrame(hostVizRaf); hostVizRaf = null; }
  mediaRecorder = null;
  if (sock) sock.emit('stream:stop');
  G('h-live-indicator').style.display = 'none';
  G('h-start-btn').style.display = '';
  G('h-stop-btn').style.display = 'none';
  setStatus('h-dot', 'h-status', 'dot-wait', 'Ready');
  toast('â¹ Stream stopped');
}

// â”€â”€ LISTENER AUDIO â€” Web Audio API based â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// How sync works:
// 1. Server records Date.now() (ts) when each chunk arrives
// 2. Listener knows clockOffset (via NTP), so can compute srvNow()
// 3. Each chunk's "play time" in AudioContext time =
//      acStart + (chunkSrvTs - streamStartSrvTime) / 1000 + TARGET_LAG/1000
//    where acStart = AudioContext.currentTime when we initialised
// 4. We use AudioContext.decodeAudioData + AudioBufferSourceNode.start(when)
//    This is sample-accurate scheduling â€” no gaps, no drift.

function startListening(mime, streamStartSrvTs) {
  stopListening(); // clean up any previous

  // Create Web Audio context
  listenerAudioCtx = new (window.AudioContext || window.webkitAudioContext)({
    sampleRate: 48000,
    latencyHint: 'playback',
  });

  // Resume if suspended (mobile)
  const resumeCtx = () => listenerAudioCtx?.resume();

  // Gain node (volume)
  listenerGain = listenerAudioCtx.createGain();
  listenerGain.gain.value = parseFloat(G('l-vol').value) || 0.9;

  // Analyser for visualizer
  listenerAnalyser = listenerAudioCtx.createAnalyser();
  listenerAnalyser.fftSize = 512;

  listenerGain.connect(listenerAnalyser);
  listenerAnalyser.connect(listenerAudioCtx.destination);

  // Record when we initialised, relative to stream start
  streamStartSrvTime = streamStartSrvTs;
  // AudioContext "start" = now, adjusted for clock offset
  // We add TARGET_LAG so we always play slightly behind live
  streamStartAcTime = listenerAudioCtx.currentTime
                    + TARGET_LAG / 1000
                    - (srvNow() - streamStartSrvTs) / 1000;

  listenerRunning = true;
  chunkQueue = [];
  nextSeq = 0;

  G('l-waiting').style.display = 'none';
  G('l-live').style.display = 'block';
  G('l-stats').style.display = 'flex';
  setStatus('l-dot', 'l-status', 'dot-live', 'ğŸ”´ Live');

  startViz('l-viz', listenerAnalyser, listenerVizRaf, raf => listenerVizRaf = raf);
  startStatsLoop();

  // Handle autoplay block
  if (listenerAudioCtx.state === 'suspended') {
    G('tap-overlay').classList.add('on');
  }

  console.log('[L] listening, TARGET_LAG=' + TARGET_LAG + 'ms');
}

function stopListening() {
  listenerRunning = false;
  chunkQueue = [];
  nextSeq = 0;
  if (listenerVizRaf) { cancelAnimationFrame(listenerVizRaf); listenerVizRaf = null; }
  if (statsRaf) { cancelAnimationFrame(statsRaf); statsRaf = null; }
  if (listenerAudioCtx) { listenerAudioCtx.close().catch(() => {}); listenerAudioCtx = null; }
  listenerGain = null; listenerAnalyser = null;
  G('l-waiting').style.display = '';
  G('l-live').style.display = 'none';
  G('l-stats').style.display = 'none';
  setStatus('l-dot', 'l-status', 'dot-wait', 'Waiting...');
}

// Drain chunk queue â€” decode and schedule each chunk
function drainQueue() {
  if (decoding || !listenerRunning || !listenerAudioCtx) return;
  if (chunkQueue.length === 0) return;

  // Sort by seq to handle out-of-order delivery
  chunkQueue.sort((a, b) => a.seq - b.seq);

  // Only process chunks we're ready for
  const chunk = chunkQueue[0];
  if (chunk.seq > nextSeq + 5) return; // too far ahead â€” wait
  chunkQueue.shift();
  nextSeq = chunk.seq + 1;

  decoding = true;
  listenerAudioCtx.decodeAudioData(chunk.data.slice(0), buffer => {
    decoding = false;

    if (!listenerRunning || !listenerAudioCtx) return;

    // Calculate WHEN to play this chunk in AudioContext time
    // chunkSrvTs = server wall clock when chunk was received by server
    // We map that to AudioContext time using our reference points
    const chunkAcTime = streamStartAcTime + (chunk.srvTs - streamStartSrvTime) / 1000;

    // If we're already past this chunk's play time, skip it (we're behind)
    const now = listenerAudioCtx.currentTime;
    if (chunkAcTime < now - 0.1) {
      console.warn('[L] skipped late chunk seq=' + chunk.seq +
        ' was ' + ((now - chunkAcTime) * 1000).toFixed(0) + 'ms late');
      drainQueue();
      return;
    }

    // Schedule playback at exact time
    const src = listenerAudioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(listenerGain);
    src.start(Math.max(now, chunkAcTime));

    drainQueue(); // process next chunk immediately
  }, err => {
    decoding = false;
    console.warn('[L] decode error', err);
    drainQueue();
  });
}

// Tap to play on mobile
function tapToPlay() {
  if (!listenerAudioCtx) return;
  listenerAudioCtx.resume().then(() => {
    G('tap-overlay').classList.remove('on');
    console.log('[L] AudioContext resumed after tap');
  });
}

// â”€â”€ VOLUME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setListenerVol(v) {
  const val = parseFloat(v);
  if (listenerGain) listenerGain.gain.value = val;
  G('l-vol-val').textContent = Math.round(val * 100) + '%';
}

// â”€â”€ VISUALIZER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startViz(canvasId, analyser, currentRaf, setRaf) {
  if (currentRaf) cancelAnimationFrame(currentRaf);
  const cv = G(canvasId);
  if (!cv || !analyser) return;
  const dpr = window.devicePixelRatio || 1;
  const W = cv.offsetWidth || 380, H = cv.offsetHeight || 52;
  cv.width = W * dpr; cv.height = H * dpr;
  const ctx = cv.getContext('2d'); ctx.scale(dpr, dpr);
  const bins = analyser.frequencyBinCount;
  const buf = new Uint8Array(bins);
  const peaks = new Float32Array(bins);
  const bw = (W / bins) * 2;

  function draw() {
    setRaf(requestAnimationFrame(draw));
    analyser.getByteFrequencyData(buf);
    ctx.fillStyle = '#05060a'; ctx.fillRect(0, 0, W, H);
    for (let i = 0; i < bins; i++) {
      const r = buf[i] / 255, h = r * H * 0.92;
      if (r > peaks[i]) peaks[i] = r; else peaks[i] *= 0.985;
      const hue = 170 + i / bins * 90;
      ctx.fillStyle = `hsla(${hue},90%,60%,${0.5 + r * 0.5})`;
      ctx.fillRect(i * (bw + 0.5), H - h, bw, h);
      if (peaks[i] > 0.04) {
        ctx.fillStyle = `hsla(${hue},100%,80%,.8)`;
        ctx.fillRect(i * (bw + 0.5), H - peaks[i] * H * 0.92 - 1, bw, 1.5);
      }
    }
  }
  draw();
}

// â”€â”€ STATS LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startStatsLoop() {
  if (statsRaf) cancelAnimationFrame(statsRaf);
  function tick() {
    statsRaf = requestAnimationFrame(tick);
    if (!listenerAudioCtx || !listenerRunning) return;
    const now = listenerAudioCtx.currentTime;
    const lag = TARGET_LAG;
    const buf = chunkQueue.length;

    // Drift = how far are we from expected play position
    const expectedSrvTime = srvNow();
    const streamElapsed = (expectedSrvTime - streamStartSrvTime) / 1000;
    const expectedAcTime = streamStartAcTime + streamElapsed;
    const drift = (expectedAcTime - now) * 1000; // ms, positive = ahead of schedule

    G('l-lag').textContent = lag + 'ms';
    G('l-drift').textContent = Math.abs(Math.round(drift)) + 'ms';
    G('l-buf').textContent = buf + ' chunks';

    // Update sync badge
    const badge = G('l-sync-badge');
    if (badge) {
      if (Math.abs(drift) < 80) {
        badge.textContent = 'â— In Sync';
        badge.className = 'badge badge-sync';
      } else {
        badge.textContent = 'âŸ³ Syncing';
        badge.className = 'badge badge-live';
      }
    }
  }
  tick();
}

// â”€â”€ LEAVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function leave() {
  stopShare();
  stopListening();
  clearInterval(window._ka);
  if (sock) { sock.disconnect(); sock = null; }
  roomCode = null; amHost = false;
  G('h-lcnt').textContent = '0';
  G('join-inp').value = '';
  G('l-waiting').style.display = '';
  G('l-live').style.display = 'none';
  G('tap-overlay').classList.remove('on');
  setConn(false);
  show('s-home');
  initSock(); // reconnect ready for next session
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
G('join-inp').addEventListener('input', function () {
  this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
});
G('join-inp').addEventListener('keydown', e => { if (e.key === 'Enter') joinRoom(); });
G('room-name').addEventListener('keydown', e => { if (e.key === 'Enter') createRoom(); });

window.addEventListener('load', () => initSock());
</script>
</body>
</html>
