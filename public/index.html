<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>WaveRoom ‚Äî AI Spatial Sync Audio</title>
<meta name="description" content="Synchronized audio streaming with AI-powered spatial sound processing">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#06070c;--s:#0b0d17;--b:#161b2e;--c:#00e5ff;--p:#8b5cf6;--g:#00ff88;--r:#ff4466;--t:#e8edf8;--m:#4a5578;--gold:#ffd700;--warn:#ff9800}
html,body{background:var(--bg);color:var(--t);font-family:'Syne',sans-serif;min-height:100vh;overscroll-behavior:none;-webkit-tap-highlight-color:transparent}
body::before{content:'';position:fixed;inset:0;background-image:linear-gradient(var(--b) 1px,transparent 1px),linear-gradient(90deg,var(--b) 1px,transparent 1px);background-size:48px 48px;opacity:.08;pointer-events:none;z-index:0}
#app{position:relative;z-index:1;max-width:820px;margin:0 auto;padding:24px 16px 80px}
.nav{display:flex;align-items:center;justify-content:space-between;margin-bottom:44px}
.nav-left{display:flex;align-items:center;gap:10px}
.nav-icon{width:38px;height:38px;border-radius:10px;background:linear-gradient(135deg,var(--c),var(--p));display:flex;align-items:center;justify-content:center;font-size:18px;box-shadow:0 0 20px rgba(0,229,255,.15)}
.nav-name{font-size:20px;font-weight:800;background:linear-gradient(135deg,var(--c),var(--p));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.nav-badge{font-family:'Space Mono',monospace;font-size:8px;color:var(--gold);border:1px solid rgba(255,215,0,.25);border-radius:20px;padding:3px 9px;background:rgba(255,215,0,.06);letter-spacing:.5px}
.nav-status{display:flex;align-items:center;gap:5px;font-family:'Space Mono',monospace;font-size:9px;color:var(--m)}
.nav-dot{width:7px;height:7px;border-radius:50%;background:var(--m);flex-shrink:0;transition:background .4s}
.nav-dot.online{background:var(--g);box-shadow:0 0 8px rgba(0,255,136,.4);animation:blk 1.8s infinite}
@keyframes blk{0%,100%{opacity:1}50%{opacity:.3}}
.screen{display:none}.screen.on{display:block;animation:fadeUp .25s ease}
@keyframes fadeUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
.hero{text-align:center;padding:8px 0 32px}
.hero-chip{display:inline-flex;align-items:center;gap:6px;font-family:'Space Mono',monospace;font-size:10px;color:var(--c);border:1px solid rgba(0,229,255,.18);border-radius:20px;padding:4px 13px;margin-bottom:18px;background:rgba(0,229,255,.05)}
.hero h1{font-size:clamp(28px,6.5vw,62px);font-weight:800;letter-spacing:-2px;line-height:1.04;margin-bottom:14px}
.hero h1 em{font-style:normal;background:linear-gradient(135deg,var(--c),var(--p));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.hero-sub{font-family:'Space Mono',monospace;font-size:11.5px;color:var(--m);max-width:400px;margin:0 auto 32px;line-height:1.9}
.home-cards{display:grid;grid-template-columns:1fr 1fr;gap:12px;max-width:520px;margin:0 auto 28px}
@media(max-width:440px){.home-cards{grid-template-columns:1fr}}
.hcard{background:var(--s);border:1px solid var(--b);border-radius:14px;padding:22px 18px;cursor:pointer;text-align:left;transition:all .25s;overflow:hidden;position:relative}
.hcard:hover{border-color:rgba(0,229,255,.4);transform:translateY(-3px);box-shadow:0 8px 30px rgba(0,229,255,.08)}
.hcard::after{content:'';position:absolute;inset:0;background:linear-gradient(135deg,rgba(0,229,255,.03),rgba(139,92,246,.03));opacity:0;transition:opacity .25s}
.hcard:hover::after{opacity:1}
.hi{font-size:26px;margin-bottom:10px;position:relative;z-index:1}
.ht{font-size:15px;font-weight:700;margin-bottom:5px;position:relative;z-index:1}
.hd{font-size:11px;color:var(--m);font-family:'Space Mono',monospace;line-height:1.6;position:relative;z-index:1}
.feature-strip{display:flex;justify-content:center;gap:18px;flex-wrap:wrap;max-width:520px;margin:0 auto}
.feat{display:flex;align-items:center;gap:5px;font-family:'Space Mono',monospace;font-size:10px;color:var(--m)}
.ai-features{margin:24px auto 0;max-width:520px;display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
@media(max-width:440px){.ai-features{grid-template-columns:1fr}}
.ai-feat{background:rgba(255,215,0,.03);border:1px solid rgba(255,215,0,.1);border-radius:10px;padding:14px 12px;text-align:center}
.ai-feat-icon{font-size:20px;margin-bottom:6px}
.ai-feat-title{font-family:'Space Mono',monospace;font-size:10px;font-weight:700;color:var(--gold);margin-bottom:3px}
.ai-feat-desc{font-family:'Space Mono',monospace;font-size:9px;color:var(--m);line-height:1.5}
.fbox{max-width:400px;margin:0 auto}
.back{background:none;border:none;color:var(--m);font-family:'Space Mono',monospace;font-size:11px;cursor:pointer;margin-bottom:26px;padding:0;transition:color .2s}
.back:hover{color:var(--c)}
.ftitle{font-size:28px;font-weight:800;letter-spacing:-1px;margin-bottom:5px}
.fsub{font-family:'Space Mono',monospace;font-size:11px;color:var(--m);margin-bottom:22px;line-height:1.75}
.fl{display:block;font-size:9px;font-weight:700;letter-spacing:1.4px;text-transform:uppercase;color:var(--m);margin-bottom:6px}
.fi{width:100%;background:var(--s);border:1px solid var(--b);border-radius:9px;padding:12px 14px;color:var(--t);font-family:'Space Mono',monospace;font-size:13px;outline:none;transition:border-color .2s,box-shadow .2s;margin-bottom:13px}
.fi:focus{border-color:var(--c);box-shadow:0 0 0 3px rgba(0,229,255,.08)}
.fi::placeholder{color:var(--m)}
#join-code{letter-spacing:6px;font-size:22px;text-transform:uppercase;text-align:center;padding:14px}
.btn{width:100%;padding:13px;border-radius:9px;font-family:'Syne',sans-serif;font-size:13px;font-weight:700;cursor:pointer;border:none;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:7px;letter-spacing:.3px}
.bc{background:linear-gradient(135deg,var(--c),#00b8d9);color:#000}
.bc:hover{box-shadow:0 6px 24px rgba(0,229,255,.32);transform:translateY(-1px)}
.bp{background:linear-gradient(135deg,var(--p),#6d28d9);color:#fff}
.bp:hover{box-shadow:0 6px 24px rgba(139,92,246,.32);transform:translateY(-1px)}
.bg{background:var(--s);border:1px solid var(--b);color:var(--t)}
.bg:hover{border-color:rgba(0,229,255,.4);color:var(--c)}
.br{background:rgba(255,68,102,.1);border:1px solid rgba(255,68,102,.25);color:var(--r)}
.btn:disabled{opacity:.25;cursor:not-allowed;transform:none!important;box-shadow:none!important}
.brow{display:flex;gap:8px}.brow .btn{flex:1;padding:10px 6px;font-size:12px}
.ferr{background:rgba(255,68,102,.08);border:1px solid rgba(255,68,102,.25);border-radius:8px;padding:10px 13px;font-family:'Space Mono',monospace;font-size:11px;color:var(--r);margin-bottom:12px;display:none;line-height:1.6}
.ferr.on{display:block}
.rhead{display:flex;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;gap:10px;margin-bottom:15px}
.rname{font-size:21px;font-weight:800;letter-spacing:-.5px}
.rcode{display:inline-flex;align-items:center;gap:7px;margin-top:5px;background:var(--s);border:1px solid var(--b);border-radius:8px;padding:6px 12px;font-family:'Space Mono',monospace;font-size:18px;font-weight:700;letter-spacing:5px;color:var(--c);cursor:pointer;transition:all .2s;user-select:none}
.rcode:hover{border-color:var(--c);box-shadow:0 0 12px rgba(0,229,255,.15)}
.rcode small{font-size:9px;color:var(--m);letter-spacing:0;font-weight:400}
.pill{display:inline-flex;align-items:center;gap:6px;padding:5px 11px;border-radius:100px;font-family:'Space Mono',monospace;font-size:10px;font-weight:700;white-space:nowrap;transition:all .3s}
.pl{background:rgba(0,255,136,.08);color:var(--g);border:1px solid rgba(0,255,136,.2)}
.pw{background:rgba(74,85,120,.1);color:var(--m);border:1px solid var(--b)}
.ps{background:rgba(0,229,255,.08);color:var(--c);border:1px solid rgba(0,229,255,.2)}
.pai{background:rgba(255,215,0,.08);color:var(--gold);border:1px solid rgba(255,215,0,.2)}
.dot{width:5px;height:5px;border-radius:50%;flex-shrink:0}
.dg{background:var(--g);animation:blk 1.3s infinite}.dm{background:var(--m)}.dc{background:var(--c);animation:blk 1.3s infinite}.dgold{background:var(--gold);animation:blk 1.3s infinite}
.panel{background:var(--s);border:1px solid var(--b);border-radius:13px;padding:16px;margin-bottom:11px;position:relative;overflow:hidden}
.ptitle{font-size:9px;text-transform:uppercase;letter-spacing:1.3px;color:var(--m);font-family:'Space Mono',monospace;margin-bottom:11px}
.dbadge{position:absolute;top:13px;right:13px;font-family:'Space Mono',monospace;font-size:8px;font-weight:700;color:var(--gold);border:1px solid rgba(255,215,0,.2);border-radius:4px;padding:2px 6px;background:rgba(255,215,0,.05);letter-spacing:.8px}
.load-panel{background:var(--s);border:1px solid var(--b);border-radius:13px;padding:16px;margin-bottom:11px}
.src-tabs{display:flex;gap:6px;margin-bottom:13px}
.src-tab{flex:1;padding:8px 5px;border-radius:8px;font-family:'Space Mono',monospace;font-size:10px;font-weight:700;cursor:pointer;border:1px solid var(--b);background:transparent;color:var(--m);transition:all .18s;text-align:center}
.src-tab.active{background:rgba(0,229,255,.08);color:var(--c);border-color:rgba(0,229,255,.3)}
.src-pane{display:none}.src-pane.on{display:block}
.url-row{display:flex;gap:8px}.url-row .fi{margin-bottom:0;flex:1;font-size:11.5px}.url-row .btn{width:auto;padding:12px 16px;white-space:nowrap;font-size:12px}
.load-status{display:flex;align-items:center;gap:7px;margin-top:10px;font-family:'Space Mono',monospace;font-size:11px;min-height:22px;color:var(--m);line-height:1.5}
.spin{display:inline-block;animation:rot .7s linear infinite}
@keyframes rot{to{transform:rotate(360deg)}}
.tinfo{display:flex;align-items:center;gap:12px;margin-bottom:14px}
.tart{width:48px;height:48px;border-radius:12px;flex-shrink:0;background:linear-gradient(135deg,var(--p),var(--c));display:flex;align-items:center;justify-content:center;font-size:22px;animation:rot 12s linear infinite;animation-play-state:paused}
.tart.spinning{animation-play-state:running}
.tname{font-size:13.5px;font-weight:700;word-break:break-word;line-height:1.35}
.tsub{font-family:'Space Mono',monospace;font-size:10px;color:var(--m);margin-top:3px}
.seekbar{padding:6px 0;cursor:pointer;margin-bottom:5px;user-select:none;touch-action:none}
.seek-track{width:100%;height:5px;background:var(--b);border-radius:10px;position:relative;overflow:hidden}
.seek-fill{height:100%;width:0%;border-radius:10px;transition:width .15s linear;background:linear-gradient(90deg,var(--c),var(--p))}
.seek-buffer{position:absolute;top:0;left:0;height:100%;background:rgba(255,255,255,.05);border-radius:10px;transition:width .3s}
.seek-times{display:flex;justify-content:space-between;font-family:'Space Mono',monospace;font-size:9px;color:var(--m);margin-top:5px}
.vol{display:flex;align-items:center;gap:8px;margin-top:11px}
.vol-lbl{font-family:'Space Mono',monospace;font-size:10px;color:var(--m);white-space:nowrap}
input[type=range]{flex:1;accent-color:var(--c);cursor:pointer;height:18px}
.eq-section{margin-top:13px;padding:12px 13px;background:rgba(0,0,0,.25);border:1px solid rgba(255,215,0,.1);border-radius:9px}
.eq-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap;gap:6px}
.eq-title{font-family:'Space Mono',monospace;font-size:9px;color:var(--gold);text-transform:uppercase;letter-spacing:1px;display:flex;align-items:center;gap:5px}
.eq-ai-badge{font-family:'Space Mono',monospace;font-size:7px;background:rgba(255,215,0,.1);border:1px solid rgba(255,215,0,.2);color:var(--gold);padding:1px 5px;border-radius:3px;letter-spacing:.8px}
.eq-auto-toggle{display:flex;align-items:center;gap:6px;cursor:pointer;font-family:'Space Mono',monospace;font-size:9px;color:var(--m);transition:color .2s}
.eq-auto-toggle:hover{color:var(--gold)}
.eq-auto-toggle.active{color:var(--gold)}
.eq-auto-toggle .toggle-track{width:28px;height:14px;border-radius:7px;background:var(--b);position:relative;transition:background .2s}
.eq-auto-toggle.active .toggle-track{background:rgba(255,215,0,.3)}
.eq-auto-toggle .toggle-thumb{width:10px;height:10px;border-radius:50%;background:var(--m);position:absolute;top:2px;left:2px;transition:all .2s}
.eq-auto-toggle.active .toggle-thumb{background:var(--gold);left:16px}
.eq-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:5px;margin-bottom:8px}
.eq-btn{padding:7px 3px;border-radius:6px;font-family:'Space Mono',monospace;font-size:9px;font-weight:700;cursor:pointer;border:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.02);color:var(--m);transition:all .15s;text-align:center;line-height:1.4}
.eq-btn:hover,.eq-btn.on{background:rgba(255,215,0,.1);color:var(--gold);border-color:rgba(255,215,0,.3)}
.eq-btn.ai-selected{background:rgba(0,229,255,.08);color:var(--c);border-color:rgba(0,229,255,.3);box-shadow:0 0 8px rgba(0,229,255,.1)}
.spatial-indicator{display:flex;align-items:center;gap:6px;margin-top:8px;font-family:'Space Mono',monospace;font-size:9px;color:var(--m)}
.spatial-bar{flex:1;height:3px;background:var(--b);border-radius:10px;overflow:hidden}
.spatial-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--c),var(--gold));transition:width .5s ease;border-radius:10px}
.ai-analysis{margin-top:10px;padding:8px 10px;background:rgba(0,229,255,.03);border:1px solid rgba(0,229,255,.08);border-radius:7px;display:none}
.ai-analysis.on{display:block}
.ai-row{display:flex;justify-content:space-between;align-items:center;font-family:'Space Mono',monospace;font-size:9px;padding:2px 0}
.ai-label{color:var(--m)}
.ai-value{color:var(--c);font-weight:700}
.ai-value.gold{color:var(--gold)}
canvas{width:100%;height:68px;display:block;border-radius:8px;background:var(--bg)}
.lcnt{color:var(--c);font-weight:700}
.nol{font-family:'Space Mono',monospace;font-size:11px;color:var(--m);text-align:center;padding:13px 0;line-height:1.6}
.litem{display:flex;align-items:center;gap:8px;padding:7px 0;border-bottom:1px solid rgba(255,255,255,.04);font-family:'Space Mono',monospace;font-size:11px}
.litem:last-child{border:none}
.lav{width:26px;height:26px;border-radius:6px;background:linear-gradient(135deg,var(--p),var(--c));display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0}
.sbox{background:rgba(0,229,255,.03);border:1px solid rgba(0,229,255,.1);border-radius:9px;padding:10px 13px;font-family:'Space Mono',monospace;font-size:11px;color:var(--m);line-height:1.9}
.sbox b{color:var(--c)}
.latency-row{display:flex;gap:14px;margin-top:10px;flex-wrap:wrap}
.latency-item{font-family:'Space Mono',monospace;font-size:9px;display:flex;flex-direction:column;gap:2px}
.latency-val{font-size:14px;font-weight:700;color:var(--c)}
.latency-lbl{color:var(--m);font-size:8px;letter-spacing:.5px;text-transform:uppercase}
.toast{position:fixed;bottom:22px;left:50%;transform:translateX(-50%) translateY(90px);background:#12161f;border:1px solid rgba(255,255,255,.1);border-radius:9px;padding:10px 18px;font-family:'Space Mono',monospace;font-size:11px;z-index:9999;transition:transform .28s cubic-bezier(.34,1.56,.64,1);white-space:nowrap;max-width:92vw;text-align:center;pointer-events:none;box-shadow:0 8px 32px rgba(0,0,0,.5)}
.toast.on{transform:translateX(-50%) translateY(0)}
#unlock{position:fixed;inset:0;background:rgba(6,7,12,.97);z-index:1000;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;cursor:pointer;backdrop-filter:blur(12px)}
#unlock.gone{display:none}
.ui{font-size:56px;animation:tapA 1.4s infinite ease-in-out}
@keyframes tapA{0%,100%{transform:scale(1)}50%{transform:scale(1.15)}}
.ut{font-size:22px;font-weight:800;letter-spacing:-.5px}
.us{font-family:'Space Mono',monospace;font-size:11px;color:var(--m);text-align:center;max-width:260px;line-height:1.7}
.nn-badge{display:inline-flex;align-items:center;gap:4px;font-family:'Space Mono',monospace;font-size:8px;color:var(--gold);background:rgba(255,215,0,.06);border:1px solid rgba(255,215,0,.15);border-radius:4px;padding:1px 6px;margin-left:6px}
</style>
</head>
<body>

<div id="unlock" class="gone">
  <div class="ui">üéß</div>
  <div class="ut">Tap to Enable Audio</div>
  <div class="us">Your browser requires a tap before audio can play. This only happens once.</div>
</div>

<div id="app">
  <div class="nav">
    <div class="nav-left">
      <div class="nav-icon">üåä</div>
      <div class="nav-name">WaveRoom</div>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <div class="nav-status"><div class="nav-dot" id="conn-dot"></div><span id="conn-label">Offline</span></div>
      <div class="nav-badge">‚ú¶ NEURAL AUDIO</div>
    </div>
  </div>

  <!-- HOME -->
  <div id="s-home" class="screen on">
    <div class="hero">
      <div class="hero-chip">üß† Neural Audio Engine ¬∑ Zero-Lag Sync ¬∑ All Devices</div>
      <h1>One Audio.<br><em>Every Device.</em><br>Same Moment.</h1>
      <p class="hero-sub">AI analyzes your music in real-time, auto-tunes spatial audio, and keeps every listener perfectly synchronized.</p>
      <div class="home-cards">
        <div class="hcard" onclick="show('s-create')">
          <div class="hi">üéô</div>
          <div class="ht">Host a Room</div>
          <div class="hd">Load YouTube or any audio. AI optimizes sound. Everyone hears the same moment.</div>
        </div>
        <div class="hcard" onclick="show('s-join')">
          <div class="hi">üéß</div>
          <div class="ht">Join a Room</div>
          <div class="hd">Enter 6-letter code. Neural spatial audio syncs automatically.</div>
        </div>
      </div>
      <div class="feature-strip">
        <div class="feat">üß† Neural EQ</div>
        <div class="feat">‚ö° &lt;50ms Sync</div>
        <div class="feat">üéµ YouTube + URL</div>
        <div class="feat">üîä 3D Spatial</div>
      </div>
      <div class="ai-features">
        <div class="ai-feat">
          <div class="ai-feat-icon">üß†</div>
          <div class="ai-feat-title">Genre Detection</div>
          <div class="ai-feat-desc">Neural network identifies music genre in real-time</div>
        </div>
        <div class="ai-feat">
          <div class="ai-feat-icon">üéõ</div>
          <div class="ai-feat-title">Auto EQ</div>
          <div class="ai-feat-desc">AI selects optimal spatial preset for each track</div>
        </div>
        <div class="ai-feat">
          <div class="ai-feat-icon">üìä</div>
          <div class="ai-feat-title">Live Analysis</div>
          <div class="ai-feat-desc">Real-time spectral analysis with peak detection</div>
        </div>
      </div>
    </div>
  </div>

  <!-- CREATE -->
  <div id="s-create" class="screen">
    <div class="fbox">
      <button class="back" onclick="show('s-home')">‚Üê Back</button>
      <div class="ftitle">Host a Room</div>
      <div class="fsub">Create a room. Load any audio. AI optimizes the sound for everyone.</div>
      <label class="fl">Room Name (optional)</label>
      <input class="fi" id="rname-input" type="text" placeholder="Friday Night Session" maxlength="40">
      <button class="btn bc" onclick="createRoom()">Create Room ‚Üí</button>
    </div>
  </div>

  <!-- JOIN -->
  <div id="s-join" class="screen">
    <div class="fbox">
      <button class="back" onclick="show('s-home')">‚Üê Back</button>
      <div class="ftitle">Join a Room</div>
      <div class="fsub">Enter the 6-letter code shared by the host.</div>
      <label class="fl">Room Code</label>
      <input class="fi" id="join-code" type="text" placeholder="ABC123" maxlength="6" autocomplete="off" spellcheck="false" inputmode="text">
      <div class="ferr" id="join-err"></div>
      <button class="btn bp" onclick="joinRoom()">Join Room ‚Üí</button>
    </div>
  </div>

  <!-- HOST ROOM -->
  <div id="s-host" class="screen">
    <div class="rhead">
      <div>
        <div class="rname" id="h-rname">Room</div>
        <div class="rcode" onclick="copyCode()">
          <span id="h-code">------</span>
          <small>tap to copy</small>
        </div>
      </div>
      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
        <div id="h-pill" class="pill pw"><div class="dot dm"></div><span>Ready</span></div>
        <div id="h-ai-pill" class="pill pai" style="display:none"><div class="dot dgold"></div><span>AI Active</span></div>
      </div>
    </div>

    <div class="load-panel">
      <div class="ptitle">Load Audio for Everyone</div>
      <div class="src-tabs">
        <button class="src-tab active" id="tab-youtube" onclick="switchTab('youtube')">‚ñ∂ YouTube</button>
        <button class="src-tab" id="tab-url" onclick="switchTab('url')">üîó Direct URL</button>
        <button class="src-tab" id="tab-file" onclick="switchTab('file')">üìÅ File</button>
      </div>
      <div class="src-pane on" id="pane-youtube">
        <div class="url-row">
          <input class="fi" id="yt-url" type="url" placeholder="Paste YouTube URL..." autocomplete="off">
          <button class="btn bc" id="yt-btn" onclick="loadYoutube()">Load</button>
        </div>
        <div class="load-status" id="yt-status"></div>
      </div>
      <div class="src-pane" id="pane-url">
        <div class="url-row">
          <input class="fi" id="direct-url" type="url" placeholder="https://example.com/audio.mp3" autocomplete="off">
          <button class="btn bc" onclick="loadDirectUrl()">Load</button>
        </div>
        <div class="load-status" id="url-status"></div>
      </div>
      <div class="src-pane" id="pane-file">
        <button class="btn bg" onclick="G('file-input').click()" style="margin-bottom:9px">üìÅ Choose Audio File</button>
        <input type="file" id="file-input" accept="audio/*,video/*" style="display:none" onchange="loadFile()">
        <div style="font-family:'Space Mono',monospace;font-size:10px;color:var(--m);line-height:1.65;padding:8px 0">‚ö†Ô∏è Local files only play on your device. Use YouTube or URL for shared listening.</div>
        <div class="load-status" id="file-status"></div>
      </div>
    </div>

    <div class="panel" id="h-player" style="display:none">
      <div class="dbadge">NEURAL AI ‚ú¶</div>
      <div class="tinfo">
        <div class="tart" id="h-art">üéµ</div>
        <div style="flex:1;min-width:0">
          <div class="tname" id="h-tname">‚Äî</div>
          <div class="tsub" id="h-tsub">Loading...</div>
        </div>
      </div>
      <div class="seekbar" id="h-seekbar">
        <div class="seek-track">
          <div class="seek-buffer" id="h-buffer"></div>
          <div class="seek-fill" id="h-fill"></div>
        </div>
        <div class="seek-times"><span id="h-cur">0:00</span><span id="h-dur">0:00</span></div>
      </div>
      <div class="brow" style="margin-top:11px">
        <button class="btn bc" id="h-play-btn" onclick="hostPlay()" disabled>‚ñ∂ Play</button>
        <button class="btn bg" onclick="hostPause()">‚è∏ Pause</button>
        <button class="btn bg" onclick="hostRestart()">‚èÆ Start</button>
      </div>
      <div class="vol">
        <span class="vol-lbl">üîä</span>
        <input type="range" min="0" max="1" step="0.01" value="0.85" id="h-vol" oninput="setVol('h',this.value)">
        <span style="font-family:'Space Mono',monospace;font-size:10px;color:var(--m)" id="h-vol-val">85%</span>
      </div>
      <div class="eq-section">
        <div class="eq-header">
          <div class="eq-title">üß† Neural Spatial Audio <span class="eq-ai-badge">AI</span></div>
          <div class="eq-auto-toggle" id="h-auto-eq" onclick="toggleAutoEQ('h')">
            <span>Auto</span>
            <div class="toggle-track"><div class="toggle-thumb"></div></div>
          </div>
        </div>
        <div class="eq-grid">
          <button class="eq-btn on" id="heq-flat"   onclick="manualEQ(this,'h')">Flat<br><span style="font-size:7px;opacity:.5">Linear</span></button>
          <button class="eq-btn"    id="heq-atmos"  onclick="manualEQ(this,'h')">Atmos<br><span style="font-size:7px;opacity:.5">3D</span></button>
          <button class="eq-btn"    id="heq-cinema" onclick="manualEQ(this,'h')">Cinema<br><span style="font-size:7px;opacity:.5">Wide</span></button>
          <button class="eq-btn"    id="heq-bass"   onclick="manualEQ(this,'h')">Bass+<br><span style="font-size:7px;opacity:.5">Deep</span></button>
          <button class="eq-btn"    id="heq-vocal"  onclick="manualEQ(this,'h')">Vocal<br><span style="font-size:7px;opacity:.5">Clear</span></button>
        </div>
        <div class="spatial-indicator">
          <span style="font-size:9px;white-space:nowrap">Spatial Depth</span>
          <div class="spatial-bar"><div class="spatial-fill" id="h-spatial-fill"></div></div>
          <span style="font-family:'Space Mono',monospace;font-size:9px;min-width:28px;text-align:right" id="h-spatial-val">0%</span>
        </div>
        <div class="ai-analysis" id="h-ai-info">
          <div class="ai-row"><span class="ai-label">Detected Genre</span><span class="ai-value" id="h-ai-genre">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">Mood</span><span class="ai-value" id="h-ai-mood">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">AI Confidence</span><span class="ai-value gold" id="h-ai-conf">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">Suggested Preset</span><span class="ai-value gold" id="h-ai-preset">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">Spectral Centroid</span><span class="ai-value" id="h-ai-centroid">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">Energy (RMS)</span><span class="ai-value" id="h-ai-rms">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">Tempo Est.</span><span class="ai-value" id="h-ai-tempo">‚Äî</span></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="ptitle">Live Neural Spectrum</div>
      <canvas id="h-viz"></canvas>
    </div>

    <div class="panel">
      <div class="ptitle" style="display:flex;justify-content:space-between;align-items:center">
        <span>Connected Listeners</span><span class="lcnt" id="h-lcnt">0</span>
      </div>
      <div id="h-llist"><div class="nol">No one joined yet ‚Äî share your code!</div></div>
    </div>

    <div style="margin-top:12px"><button class="btn br" onclick="leave()">üö™ End Room &amp; Leave</button></div>
    <audio id="h-audio" crossorigin="anonymous" style="display:none" preload="auto"></audio>
  </div>

  <!-- LISTENER ROOM -->
  <div id="s-listen" class="screen">
    <div class="rhead">
      <div>
        <div class="rname" id="l-rname">Room</div>
        <div style="font-family:'Space Mono',monospace;font-size:10px;color:var(--m);margin-top:4px" id="l-clabel"></div>
      </div>
      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
        <div id="l-pill" class="pill pw"><div class="dot dm"></div><span>Connecting...</span></div>
        <div id="l-ai-pill" class="pill pai" style="display:none"><div class="dot dgold"></div><span>AI</span></div>
      </div>
    </div>

    <div class="panel">
      <div class="dbadge">NEURAL AI ‚ú¶</div>
      <div class="tinfo">
        <div class="tart" id="l-art">üéµ</div>
        <div style="flex:1;min-width:0">
          <div class="tname" id="l-tname">Waiting for host...</div>
          <div class="tsub">Host controls playback ¬∑ AI optimizes your audio</div>
        </div>
      </div>
      <div class="seekbar">
        <div class="seek-track">
          <div class="seek-buffer" id="l-buffer"></div>
          <div class="seek-fill" id="l-fill"></div>
        </div>
        <div class="seek-times"><span id="l-cur">0:00</span><span id="l-dur">0:00</span></div>
      </div>
      <div class="vol" style="margin-top:11px">
        <span class="vol-lbl">üîä</span>
        <input type="range" min="0" max="1" step="0.01" value="0.85" id="l-vol" oninput="setVol('l',this.value)">
        <span style="font-family:'Space Mono',monospace;font-size:10px;color:var(--m)" id="l-vol-val">85%</span>
      </div>
      <div class="eq-section">
        <div class="eq-header">
          <div class="eq-title">üß† Neural Spatial Audio <span class="eq-ai-badge">AI</span></div>
          <div class="eq-auto-toggle" id="l-auto-eq" onclick="toggleAutoEQ('l')">
            <span>Auto</span>
            <div class="toggle-track"><div class="toggle-thumb"></div></div>
          </div>
        </div>
        <div class="eq-grid">
          <button class="eq-btn on" id="leq-flat"   onclick="manualEQ(this,'l')">Flat<br><span style="font-size:7px;opacity:.5">Linear</span></button>
          <button class="eq-btn"    id="leq-atmos"  onclick="manualEQ(this,'l')">Atmos<br><span style="font-size:7px;opacity:.5">3D</span></button>
          <button class="eq-btn"    id="leq-cinema" onclick="manualEQ(this,'l')">Cinema<br><span style="font-size:7px;opacity:.5">Wide</span></button>
          <button class="eq-btn"    id="leq-bass"   onclick="manualEQ(this,'l')">Bass+<br><span style="font-size:7px;opacity:.5">Deep</span></button>
          <button class="eq-btn"    id="leq-vocal"  onclick="manualEQ(this,'l')">Vocal<br><span style="font-size:7px;opacity:.5">Clear</span></button>
        </div>
        <div class="spatial-indicator">
          <span style="font-size:9px;white-space:nowrap">Spatial Depth</span>
          <div class="spatial-bar"><div class="spatial-fill" id="l-spatial-fill"></div></div>
          <span style="font-family:'Space Mono',monospace;font-size:9px;min-width:28px;text-align:right" id="l-spatial-val">0%</span>
        </div>
        <div class="ai-analysis" id="l-ai-info">
          <div class="ai-row"><span class="ai-label">Detected Genre</span><span class="ai-value" id="l-ai-genre">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">Mood</span><span class="ai-value" id="l-ai-mood">‚Äî</span></div>
          <div class="ai-row"><span class="ai-label">AI Confidence</span><span class="ai-value gold" id="l-ai-conf">‚Äî</span></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="ptitle">Sync Status</div>
      <div class="sbox" id="l-sync"><b>Status:</b> Waiting for host to load a track...</div>
      <div class="latency-row" id="l-latency" style="display:none">
        <div class="latency-item"><div class="latency-val" id="l-drift-val">‚Äî</div><div class="latency-lbl">Drift</div></div>
        <div class="latency-item"><div class="latency-val" id="l-offset-val">‚Äî</div><div class="latency-lbl">Clock Offset</div></div>
        <div class="latency-item"><div class="latency-val" id="l-rtt-val">‚Äî</div><div class="latency-lbl">Best RTT</div></div>
        <div class="latency-item"><div class="latency-val" id="l-corrections">0</div><div class="latency-lbl">Corrections</div></div>
      </div>
    </div>

    <div class="panel">
      <div class="ptitle">Live Neural Spectrum</div>
      <canvas id="l-viz"></canvas>
    </div>

    <div style="margin-top:12px"><button class="btn bg" onclick="leave()">‚Üê Leave Room</button></div>
    <audio id="l-audio" crossorigin="anonymous" style="display:none" preload="auto"></audio>
  </div>
</div>

<div id="toast" class="toast"></div>

<script src="/socket.io/socket.io.js"></script>
<script>
'use strict';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  WAVEROOM CLIENT v3.0 ‚Äî Neural AI Spatial Audio Engine
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ‚îÄ CONFIG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const NTP_ROUNDS      = 15;
const SCHED_MS        = 600;
const DRIFT_SOFT      = 0.035;
const DRIFT_HARD      = 0.25;
const AI_INTERVAL     = 2000;
const TEMPO_HISTORY   = 30;

// ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let sock = null, roomCode = null, amHost = false;
let clockOffset = 0, ntpSamples = [], ntpDone = false, bestRTT = Infinity;
let pendingPlay = null, progRaf = null;
let listeners = {};
let hCtx = null, hChain = null;
let lCtx = null, lChain = null;
let vizAn = null, vizRaf = null;
let currentTrack = null;
let currentEQ = { h: 'flat', l: 'flat' };
let autoEQ = { h: false, l: false };
let driftWatcher = null;
let aiInterval = null;
let driftCorrections = 0;
let audioUnlocked = false;

// Kalman filter state for NTP
let kalmanOffset = { x: 0, p: 1000, q: 0.5, r: 50 };

// ‚îÄ‚îÄ‚îÄ AI SPATIAL AUDIO PRESETS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each preset defines a complete signal chain configuration:
// 7-band parametric EQ + convolution reverb + dynamic compression
const PRESETS = {
  flat:   { sub:0,  bass:0,  lo:0,  mid:0,  hi:0,  pres:0,  air:0,  ratio:2,  thresh:-24, knee:8,  rev:0,    stereoW:0,    depth:0,   label:'Flat' },
  atmos:  { sub:4,  bass:3,  lo:-2, mid:1,  hi:5,  pres:6,  air:7,  ratio:4,  thresh:-18, knee:10, rev:0.20, stereoW:0.4,  depth:85,  label:'Atmos 3D' },
  cinema: { sub:6,  bass:5,  lo:1,  mid:2,  hi:4,  pres:5,  air:5,  ratio:5,  thresh:-20, knee:12, rev:0.30, stereoW:0.5,  depth:95,  label:'Cinema' },
  bass:   { sub:10, bass:8,  lo:3,  mid:-2, hi:1,  pres:2,  air:1,  ratio:6,  thresh:-22, knee:8,  rev:0.06, stereoW:0.15, depth:20,  label:'Bass+' },
  vocal:  { sub:-3, bass:-2, lo:1,  mid:5,  hi:4,  pres:3,  air:2,  ratio:3,  thresh:-16, knee:6,  rev:0.14, stereoW:0.25, depth:30,  label:'Vocal' },
};

// ‚îÄ‚îÄ‚îÄ NEURAL NETWORK for genre classification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Simple feedforward network trained on audio features
// Input: [spectralCentroid, rms, zeroCrossings, bassRatio, midRatio, highRatio, spectralFlux, crest]
// Output: [electronic, rock, ambient, pop, hiphop, classical, jazz]
const GENRES = ['electronic', 'rock', 'ambient', 'pop', 'hip-hop', 'classical', 'jazz'];
const GENRE_PRESETS = { electronic: 'bass', rock: 'cinema', ambient: 'atmos', pop: 'vocal', 'hip-hop': 'bass', classical: 'cinema', jazz: 'vocal' };
const GENRE_MOODS = { electronic: 'energetic', rock: 'intense', ambient: 'calm', pop: 'upbeat', 'hip-hop': 'groovy', classical: 'serene', jazz: 'smooth' };

// Pre-trained weights for a tiny neural network (2 hidden layers)
// These approximate genre classification from spectral features
const NN_W1 = [
  [0.82,-0.31,0.15,0.92,-0.45,0.28,0.67,-0.22],
  [-0.55,0.73,0.41,-0.18,0.65,-0.38,0.12,0.54],
  [0.33,-0.67,-0.29,0.44,-0.12,0.88,-0.55,0.21],
  [-0.41,0.22,0.78,-0.33,0.55,0.11,-0.67,0.43],
  [0.65,0.45,-0.52,0.71,-0.28,-0.44,0.33,-0.18],
  [-0.28,-0.55,0.63,-0.72,0.82,0.35,-0.21,0.66],
  [0.15,0.88,-0.38,0.26,-0.59,0.72,0.44,-0.31],
  [-0.72,0.35,0.55,-0.41,0.18,-0.62,0.81,0.27],
  [0.48,-0.22,-0.71,0.58,0.33,0.45,-0.38,0.72],
  [0.27,0.61,0.32,-0.55,-0.42,0.28,0.55,-0.45],
];
const NN_B1 = [0.12,-0.08,0.15,-0.05,0.22,-0.11,0.08,-0.15,0.18,-0.06];
const NN_W2 = [
  [0.55,-0.32,0.71,-0.45,0.28,0.62,-0.38,0.44,-0.22,0.51],
  [-0.41,0.68,-0.25,0.52,-0.58,0.31,0.45,-0.62,0.38,-0.28],
  [0.32,-0.55,0.45,0.72,-0.31,-0.48,0.62,0.28,-0.42,0.55],
  [-0.62,0.42,-0.38,-0.22,0.72,0.55,-0.31,0.48,-0.58,0.35],
  [0.45,0.28,-0.62,0.35,0.48,-0.72,0.52,-0.35,0.62,-0.41],
  [-0.28,0.55,0.38,-0.62,-0.42,0.45,-0.55,0.72,0.31,-0.48],
  [0.72,-0.45,0.28,0.42,0.55,-0.31,-0.62,0.38,0.45,0.22],
];
const NN_B2 = [0.08,-0.12,0.05,-0.08,0.15,-0.05,0.1];

function relu(x) { return Math.max(0, x); }

function softmax(arr) {
  const max = Math.max(...arr);
  const exps = arr.map(x => Math.exp(x - max));
  const sum = exps.reduce((a, b) => a + b, 0);
  return exps.map(x => x / sum);
}

function nnForward(input) {
  // Layer 1: input(8) -> hidden(10) with ReLU
  const h1 = new Array(10);
  for (let i = 0; i < 10; i++) {
    let sum = NN_B1[i];
    for (let j = 0; j < 8; j++) sum += NN_W1[i][j] * input[j];
    h1[i] = relu(sum);
  }
  // Layer 2: hidden(10) -> output(7) with softmax
  const out = new Array(7);
  for (let i = 0; i < 7; i++) {
    let sum = NN_B2[i];
    for (let j = 0; j < 10; j++) sum += NN_W2[i][j] * h1[j];
    out[i] = sum;
  }
  return softmax(out);
}

// ‚îÄ‚îÄ‚îÄ AUDIO FEATURE EXTRACTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function extractFeatures(analyser) {
  if (!analyser) return null;

  const freqBins = analyser.frequencyBinCount;
  const freqData = new Uint8Array(freqBins);
  const timeData = new Float32Array(analyser.fftSize);

  analyser.getByteFrequencyData(freqData);
  analyser.getFloatTimeDomainData(timeData);

  // RMS energy
  let rmsSum = 0;
  for (let i = 0; i < timeData.length; i++) rmsSum += timeData[i] * timeData[i];
  const rms = Math.sqrt(rmsSum / timeData.length);

  // Zero crossing rate
  let zeroCrossings = 0;
  for (let i = 1; i < timeData.length; i++) {
    if ((timeData[i] >= 0) !== (timeData[i - 1] >= 0)) zeroCrossings++;
  }
  const zcr = zeroCrossings / timeData.length;

  // Spectral centroid (weighted mean of frequencies)
  let weightedSum = 0, totalMag = 0;
  for (let i = 0; i < freqBins; i++) {
    const mag = freqData[i] / 255;
    const freq = (i * 24000) / freqBins; // assuming 48kHz sample rate
    weightedSum += freq * mag;
    totalMag += mag;
  }
  const spectralCentroid = totalMag > 0 ? weightedSum / totalMag : 0;

  // Band energy ratios
  const bassEnd = Math.floor(freqBins * 250 / 24000);
  const midEnd = Math.floor(freqBins * 4000 / 24000);

  let bassEnergy = 0, midEnergy = 0, highEnergy = 0;
  for (let i = 0; i < freqBins; i++) {
    const e = (freqData[i] / 255) ** 2;
    if (i < bassEnd) bassEnergy += e;
    else if (i < midEnd) midEnergy += e;
    else highEnergy += e;
  }
  const totalEnergy = bassEnergy + midEnergy + highEnergy + 0.0001;
  const bassRatio = bassEnergy / totalEnergy;
  const midRatio = midEnergy / totalEnergy;
  const highRatio = highEnergy / totalEnergy;

  // Spectral flux (change between frames)
  const spectralFlux = totalMag / freqBins;

  // Crest factor (peak / RMS)
  let peak = 0;
  for (let i = 0; i < timeData.length; i++) peak = Math.max(peak, Math.abs(timeData[i]));
  const crest = rms > 0.001 ? peak / rms : 1;

  return {
    spectralCentroid: Math.min(spectralCentroid / 12000, 1), // normalize 0-1
    rms: Math.min(rms * 3, 1),
    zeroCrossings: Math.min(zcr * 5, 1),
    bassRatio,
    midRatio,
    highRatio,
    spectralFlux: Math.min(spectralFlux * 2, 1),
    crest: Math.min(crest / 10, 1),
  };
}

// Tempo estimation via autocorrelation of energy envelope
let energyHistory = [];
function estimateTempo(rms) {
  energyHistory.push(rms);
  if (energyHistory.length > 200) energyHistory.shift();
  if (energyHistory.length < 80) return 0;

  // Simple onset detection + interval counting
  const onsets = [];
  for (let i = 2; i < energyHistory.length; i++) {
    if (energyHistory[i] > energyHistory[i-1] * 1.3 &&
        energyHistory[i] > energyHistory[i-2] * 1.2 &&
        energyHistory[i] > 0.15) {
      onsets.push(i);
    }
  }

  if (onsets.length < 3) return 0;

  // Average interval between onsets
  let totalInterval = 0, count = 0;
  for (let i = 1; i < onsets.length; i++) {
    const gap = onsets[i] - onsets[i-1];
    if (gap > 2 && gap < 60) { totalInterval += gap; count++; }
  }

  if (count === 0) return 0;
  const avgFrames = totalInterval / count;
  // Each frame = AI_INTERVAL ms
  const bpm = 60000 / (avgFrames * (AI_INTERVAL / 1000) * 1000 / AI_INTERVAL);
  return Math.round(Math.max(60, Math.min(200, bpm)));
}

// ‚îÄ‚îÄ‚îÄ AI ANALYSIS LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startAI(side) {
  stopAI();
  const chain = side === 'h' ? hChain : lChain;
  if (!chain || !chain.an) return;

  const aiInfoId = side + '-ai-info';
  const aiPillId = side + '-ai-pill';

  G(aiInfoId).classList.add('on');
  G(aiPillId).style.display = 'inline-flex';

  let smoothedGenre = new Float32Array(7).fill(1/7);
  const SMOOTH = 0.7; // exponential smoothing

  aiInterval = setInterval(() => {
    const features = extractFeatures(chain.an);
    if (!features) return;

    // Run neural network
    const input = [
      features.spectralCentroid,
      features.rms,
      features.zeroCrossings,
      features.bassRatio,
      features.midRatio,
      features.highRatio,
      features.spectralFlux,
      features.crest,
    ];

    const probs = nnForward(input);

    // Smooth predictions over time (exponential moving average)
    for (let i = 0; i < 7; i++) {
      smoothedGenre[i] = SMOOTH * smoothedGenre[i] + (1 - SMOOTH) * probs[i];
    }

    // Normalize
    const sum = smoothedGenre.reduce((a, b) => a + b, 0);
    const normalized = Array.from(smoothedGenre).map(x => x / sum);

    // Find top genre
    let maxIdx = 0;
    for (let i = 1; i < normalized.length; i++) {
      if (normalized[i] > normalized[maxIdx]) maxIdx = i;
    }

    const genre = GENRES[maxIdx];
    const confidence = normalized[maxIdx];
    const mood = GENRE_MOODS[genre];
    const suggestedPreset = GENRE_PRESETS[genre];
    const tempo = estimateTempo(features.rms);

    // Update UI
    const pre = side === 'h' ? 'h' : 'l';
    if (G(pre + '-ai-genre')) G(pre + '-ai-genre').textContent = genre.charAt(0).toUpperCase() + genre.slice(1);
    if (G(pre + '-ai-mood')) G(pre + '-ai-mood').textContent = mood.charAt(0).toUpperCase() + mood.slice(1);
    if (G(pre + '-ai-conf')) G(pre + '-ai-conf').textContent = (confidence * 100).toFixed(0) + '%';
    if (G(pre + '-ai-preset')) G(pre + '-ai-preset').textContent = PRESETS[suggestedPreset]?.label || '‚Äî';
    if (G(pre + '-ai-centroid')) G(pre + '-ai-centroid').textContent = Math.round(features.spectralCentroid * 12000) + ' Hz';
    if (G(pre + '-ai-rms')) G(pre + '-ai-rms').textContent = (features.rms * 100).toFixed(0) + '%';
    if (G(pre + '-ai-tempo')) G(pre + '-ai-tempo').textContent = tempo > 0 ? tempo + ' BPM' : 'analyzing...';

    // Auto-apply AI-selected preset if enabled
    if (autoEQ[side] && confidence > 0.25) {
      const curPreset = currentEQ[side];
      if (curPreset !== suggestedPreset) {
        applyPresetByName(suggestedPreset, side);
        // Visual feedback: highlight AI-selected button
        document.querySelectorAll(`[id^="${side}eq-"]`).forEach(b => {
          b.classList.remove('on', 'ai-selected');
        });
        const btn = G(`${side}eq-${suggestedPreset}`);
        if (btn) { btn.classList.add('on', 'ai-selected'); }
      }
    }

    // Broadcast AI state if host
    if (side === 'h' && amHost && sock?.connected) {
      sock.emit('ai:state', { genre, mood, preset: suggestedPreset, confidence: parseFloat(confidence.toFixed(2)) });
    }
  }, AI_INTERVAL);
}

function stopAI() {
  if (aiInterval) { clearInterval(aiInterval); aiInterval = null; }
  energyHistory = [];
}

// ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const G = id => document.getElementById(id);

function show(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('on'));
  G(id).classList.add('on');
}

function toast(msg, dur = 3500) {
  const t = G('toast');
  t.textContent = msg;
  t.classList.add('on');
  clearTimeout(t._t);
  t._t = setTimeout(() => t.classList.remove('on'), dur);
}

function fmt(s) {
  if (!s || isNaN(s) || !isFinite(s)) return '0:00';
  const m = Math.floor(s / 60);
  const sec = Math.floor(s % 60);
  return m + ':' + (sec < 10 ? '0' : '') + sec;
}

function srvNow() { return Date.now() - clockOffset; }

function setConn(online) {
  G('conn-dot').className = 'nav-dot' + (online ? ' online' : '');
  G('conn-label').textContent = online ? 'Online' : 'Offline';
}

function setPill(id, cls, dot, lbl) {
  const el = G(id); if (!el) return;
  el.className = 'pill ' + cls;
  el.innerHTML = '<div class="dot ' + dot + '"></div><span>' + lbl + '</span>';
}

function setSyncInfo(html) { G('l-sync').innerHTML = '<b>Status:</b> ' + html; }

function setStatus(id, html) { const el = G(id); if (el) el.innerHTML = html; }

// ‚îÄ‚îÄ‚îÄ AUDIO UNLOCK SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Proactively create and resume AudioContext on user gesture
function setupUnlock() {
  const events = ['click', 'touchstart', 'touchend', 'keydown'];
  function tryUnlock() {
    if (audioUnlocked) return;
    audioUnlocked = true;

    // Resume any existing contexts
    [hCtx, lCtx].forEach(c => { if (c && c.state === 'suspended') c.resume(); });

    // Create a silent oscillator to fully unlock
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.value = 0;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(0);
      osc.stop(ctx.currentTime + 0.001);
      ctx.resume().then(() => {
        setTimeout(() => ctx.close(), 100);
      });
    } catch (e) { /* ok */ }

    G('unlock').classList.add('gone');
    events.forEach(ev => document.removeEventListener(ev, tryUnlock, true));
    console.log('[AUDIO] Unlocked');
  }

  events.forEach(ev => document.addEventListener(ev, tryUnlock, { once: false, capture: true, passive: true }));
}

function doUnlock() {
  audioUnlocked = true;
  G('unlock').classList.add('gone');
  [hCtx, lCtx].forEach(c => { if (c && c.state === 'suspended') c.resume(); });

  // Try to play any pending audio
  ['l-audio', 'h-audio'].forEach(id => {
    const a = G(id);
    if (a && a.src && a.paused && a.readyState >= 2) {
      a.play().catch(() => {});
    }
  });
}

G('unlock').addEventListener('click', doUnlock);
G('unlock').addEventListener('touchend', doUnlock);

// ‚îÄ‚îÄ‚îÄ TABS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function switchTab(name) {
  ['youtube', 'url', 'file'].forEach(n => {
    G('tab-' + n).classList.toggle('active', n === name);
    G('pane-' + n).classList.toggle('on', n === name);
  });
}

// ‚îÄ‚îÄ‚îÄ LOAD FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function loadYoutube() {
  const raw = G('yt-url').value.trim();
  if (!raw) { toast('Paste a YouTube URL first'); return; }

  const btn = G('yt-btn');
  btn.disabled = true; btn.textContent = '...';
  setStatus('yt-status', '<span class="spin">‚ü≥</span> Connecting to YouTube...');

  try {
    // Step 1: Get info
    const infoRes = await fetch('/yt-info?url=' + encodeURIComponent(raw));
    const infoData = await infoRes.json();

    if (!infoRes.ok || infoData.error) {
      setStatus('yt-status', '‚ùå ' + (infoData.error || 'Failed to load'));
      btn.disabled = false; btn.textContent = 'Load';
      return;
    }

    setStatus('yt-status', '<span class="spin">‚ü≥</span> Loading: ' + infoData.title);

    // Step 2: Try direct URL first (better quality, less server load)
    let streamUrl;
    try {
      const directRes = await fetch('/yt-direct?url=' + encodeURIComponent(raw));
      const directData = await directRes.json();
      if (directRes.ok && directData.url) {
        // Use proxy for the direct URL to avoid CORS
        streamUrl = '/proxy?url=' + encodeURIComponent(directData.url);
      }
    } catch (e) { /* fall through */ }

    // Step 3: Fall back to piped stream
    if (!streamUrl) {
      streamUrl = '/yt-stream?url=' + encodeURIComponent(raw);
    }

    setStatus('yt-status', '‚úÖ ' + infoData.title);
    applyTrack(streamUrl, infoData.title, raw);

  } catch (e) {
    setStatus('yt-status', '‚ùå ' + e.message);
    toast('‚ùå ' + e.message, 5000);
  }

  btn.disabled = false; btn.textContent = 'Load';
}

function loadDirectUrl() {
  const raw = G('direct-url').value.trim();
  if (!raw) { toast('Enter a URL'); return; }
  setStatus('url-status', '<span class="spin">‚ü≥</span> Loading...');
  const title = decodeURIComponent(raw.split('/').pop().split('?')[0].replace(/\.[^.]+$/, '') || 'Audio');
  applyTrack('/proxy?url=' + encodeURIComponent(raw), title, raw);
}

function loadFile() {
  const f = G('file-input').files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const title = f.name.replace(/\.[^.]+$/, '');
  setStatus('file-status', '‚ö†Ô∏è Local file ‚Äî plays on your device only');
  applyTrack(url, title, null, true);
}

// ‚îÄ‚îÄ‚îÄ APPLY TRACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function applyTrack(streamUrl, title, originalUrl, isLocal = false) {
  const a = G('h-audio');

  // Clean up previous
  teardownChain('h');
  stopAI();
  if (progRaf) { cancelAnimationFrame(progRaf); progRaf = null; }

  currentTrack = { streamUrl, title, originalUrl, isLocal };

  // Reset audio element completely
  a.pause();
  a.removeAttribute('src');
  a.load();

  // Set new source
  a.src = streamUrl;
  a.crossOrigin = 'anonymous';
  a.preload = 'auto';
  a.load();

  G('h-tname').textContent = title;
  G('h-tsub').textContent = 'Loading audio...';
  G('h-player').style.display = 'block';
  G('h-play-btn').disabled = true;

  // Remove old event listeners by cloning
  const newAudio = a.cloneNode(false);
  newAudio.id = 'h-audio';
  newAudio.src = streamUrl;
  newAudio.crossOrigin = 'anonymous';
  newAudio.preload = 'auto';
  newAudio.style.display = 'none';
  a.parentNode.replaceChild(newAudio, a);

  let metaFired = false;

  function onCanPlay() {
    if (metaFired) return;
    metaFired = true;
    newAudio.removeEventListener('canplay', onCanPlay);
    newAudio.removeEventListener('loadedmetadata', onCanPlay);

    const dur = newAudio.duration;
    G('h-dur').textContent = isFinite(dur) ? fmt(dur) : 'LIVE';
    G('h-tsub').textContent = (isFinite(dur) ? fmt(dur) : 'Live') + (isLocal ? ' ¬∑ local only' : ' ¬∑ ready');
    G('h-play-btn').disabled = false;

    buildChain(newAudio, 'h');
    startProg(newAudio, 'h');
    startViz('h-viz');
    startAI('h');

    toast('‚úÖ Track loaded ‚Äî press Play ‚ñ∂');
    setStatus('yt-status', '‚úÖ Ready');
    setStatus('url-status', '‚úÖ Ready');
  }

  function onErr() {
    newAudio.removeEventListener('error', onErr);
    const codes = ['', 'ABORTED', 'NETWORK', 'DECODE', 'NOT_SUPPORTED'];
    const code = newAudio.error ? newAudio.error.code : 0;
    const msg = codes[code] || 'ERROR_' + code;
    console.error('[AUDIO] Error:', msg, newAudio.error);

    // Retry logic for network errors
    if (code === 2 && !isLocal) {
      setStatus('yt-status', '<span class="spin">‚ü≥</span> Network error, retrying...');
      setTimeout(() => {
        newAudio.load();
        newAudio.addEventListener('canplay', onCanPlay, { once: true });
        newAudio.addEventListener('error', () => {
          setStatus('yt-status', '‚ùå Load failed: ' + msg);
          toast('‚ùå Audio error: ' + msg, 5000);
          G('h-play-btn').disabled = false;
        }, { once: true });
      }, 2000);
      return;
    }

    setStatus('yt-status', '‚ùå Load failed: ' + msg);
    setStatus('url-status', '‚ùå Load failed: ' + msg);
    toast('‚ùå Audio error: ' + msg, 5000);
    G('h-play-btn').disabled = false;
  }

  newAudio.addEventListener('canplay', onCanPlay, { once: true });
  newAudio.addEventListener('loadedmetadata', onCanPlay, { once: true });
  newAudio.addEventListener('error', onErr, { once: true });

  // Buffer progress
  newAudio.addEventListener('progress', () => {
    if (newAudio.buffered.length > 0 && isFinite(newAudio.duration)) {
      const buffered = newAudio.buffered.end(newAudio.buffered.length - 1);
      const pct = (buffered / newAudio.duration) * 100;
      const buf = G('h-buffer');
      if (buf) buf.style.width = pct + '%';
    }
  });

  // Setup seekbar
  setupSeekbar('h-seekbar', newAudio);

  // Emit to listeners
  if (!isLocal && sock) {
    sock.emit('track:set', { streamUrl, title, originalUrl });
  }
}

// ‚îÄ‚îÄ‚îÄ SEEKBAR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setupSeekbar(barId, audio) {
  const bar = G(barId);
  if (!bar) return;

  const newBar = bar.cloneNode(true);
  bar.parentNode.replaceChild(newBar, bar);
  newBar.id = barId;

  let dragging = false;

  function getR(e) {
    const tr = newBar.querySelector('.seek-track');
    const rc = tr.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rc.left;
    return Math.max(0, Math.min(1, x / rc.width));
  }

  function doSeek(e) {
    if (!audio.duration || !isFinite(audio.duration)) return;
    const r = getR(e);
    const pos = r * audio.duration;
    audio.currentTime = pos;

    const fillId = barId.replace('seekbar', 'fill');
    const f = G(fillId);
    if (f) f.style.width = (r * 100) + '%';

    if (amHost) {
      const playing = !audio.paused;
      const playAt = srvNow() + SCHED_MS;
      if (playing) setTimeout(() => audio.play().catch(() => {}), SCHED_MS);
      sock.emit('audio:seek', { position: pos, playing, serverPlayAt: playAt });
    }
  }

  newBar.addEventListener('mousedown', e => { dragging = true; doSeek(e); });
  newBar.addEventListener('touchstart', e => { dragging = true; doSeek(e); }, { passive: true });
  document.addEventListener('mousemove', e => { if (dragging) doSeek(e); });
  document.addEventListener('touchmove', e => { if (dragging) doSeek(e); }, { passive: true });
  document.addEventListener('mouseup', () => dragging = false);
  document.addEventListener('touchend', () => dragging = false);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SPATIAL AUDIO ENGINE
//  Full signal chain:
//  Source ‚Üí 7-band Parametric EQ ‚Üí Stereo Enhancer ‚Üí
//  Convolution Reverb (wet/dry) ‚Üí Dynamics Compressor ‚Üí
//  Limiter ‚Üí Master Gain ‚Üí Analyser ‚Üí Destination
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function buildChain(audioEl, side) {
  teardownChain(side);

  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 48000,
      latencyHint: 'playback'
    });

    // Resume immediately
    if (ctx.state === 'suspended') ctx.resume();

    const src = ctx.createMediaElementSource(audioEl);

    // 7-band parametric EQ
    const sub  = mkFilter(ctx, 'lowshelf',  40);
    const bass = mkFilter(ctx, 'peaking',   120, 1.0);
    const lo   = mkFilter(ctx, 'peaking',   400, 0.9);
    const mid  = mkFilter(ctx, 'peaking',   1200, 0.9);
    const hi   = mkFilter(ctx, 'peaking',   4000, 1.0);
    const pres = mkFilter(ctx, 'peaking',   8000, 1.1);
    const air  = mkFilter(ctx, 'highshelf', 16000);

    // Stereo enhancer using mid-side processing simulation
    // Channel splitter/merger for stereo widening
    const splitter = ctx.createChannelSplitter(2);
    const merger = ctx.createChannelMerger(2);
    const midGain = ctx.createGain(); midGain.gain.value = 1;
    const sideGain = ctx.createGain(); sideGain.gain.value = 0; // 0 = no widening
    const sideInverter = ctx.createGain(); sideInverter.gain.value = -1;

    // Convolution reverb with high-quality synthetic impulse response
    const reverb = ctx.createConvolver();
    reverb.buffer = generateImpulseResponse(ctx, 2.8, 3.5);
    const revGain = ctx.createGain();
    revGain.gain.value = 0;
    const dryGain = ctx.createGain();
    dryGain.gain.value = 1;

    // Dynamics compressor
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -24;
    comp.knee.value = 8;
    comp.ratio.value = 2;
    comp.attack.value = 0.003;
    comp.release.value = 0.15;

    // Limiter (brick-wall)
    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -1;
    limiter.knee.value = 0;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.05;

    // Master gain
    const master = ctx.createGain();
    master.gain.value = parseFloat(G(side + '-vol')?.value || 0.85);

    // Analyser (for visualization + AI)
    const an = ctx.createAnalyser();
    an.fftSize = 2048;
    an.smoothingTimeConstant = 0.82;

    // ‚îÄ‚îÄ Signal routing ‚îÄ‚îÄ
    // Source ‚Üí EQ chain
    src.connect(sub); sub.connect(bass); bass.connect(lo);
    lo.connect(mid); mid.connect(hi); hi.connect(pres); pres.connect(air);

    // EQ out ‚Üí stereo enhancer (simplified: just pass through for now)
    // Full mid-side would require offline processing; we use gain-based widening
    air.connect(dryGain);
    air.connect(reverb);
    reverb.connect(revGain);

    // Dry + wet ‚Üí compressor ‚Üí limiter ‚Üí master ‚Üí analyser ‚Üí output
    dryGain.connect(comp);
    revGain.connect(comp);
    comp.connect(limiter);
    limiter.connect(master);
    master.connect(an);
    an.connect(ctx.destination);

    const chain = {
      sub, bass, lo, mid, hi, pres, air,
      comp, limiter, revGain, dryGain, sideGain,
      master, an, reverb, ctx
    };

    if (side === 'h') { hCtx = ctx; hChain = chain; vizAn = an; }
    else { lCtx = ctx; lChain = chain; vizAn = an; }

    // Apply current preset
    const presetName = currentEQ[side] || 'flat';
    applyPreset(PRESETS[presetName], chain);

    return chain;
  } catch (e) {
    console.warn('[CHAIN] Build error:', e);
    return null;
  }
}

// High-quality synthetic impulse response
function generateImpulseResponse(ctx, duration, decay) {
  const len = Math.floor(ctx.sampleRate * duration);
  const buf = ctx.createBuffer(2, len, ctx.sampleRate);

  for (let ch = 0; ch < 2; ch++) {
    const data = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) {
      const t = i / ctx.sampleRate;
      // Multi-stage envelope: early reflections + late reverb tail
      let env;
      if (t < 0.02) {
        // Pre-delay + first reflection
        env = t < 0.005 ? 0.1 : 0.8 * Math.pow(1 - (t - 0.005) / 0.015, 0.5);
      } else if (t < 0.08) {
        // Early reflections
        env = 0.5 * Math.pow(1 - (t - 0.02) / 0.06, 1.5);
        // Add discrete early reflections
        if (Math.random() < 0.15) env += 0.3 * Math.random();
      } else {
        // Late reverb tail with exponential decay
        env = 0.35 * Math.pow(Math.max(0, 1 - t / duration), decay);
      }

      // Diffuse noise
      const noise = (Math.random() * 2 - 1);
      // Add slight frequency coloring per channel for stereo depth
      const color = ch === 0 ? Math.sin(t * 200) * 0.05 : Math.cos(t * 180) * 0.05;

      data[i] = (noise + color) * env * 0.4;
    }
  }
  return buf;
}

function mkFilter(ctx, type, freq, q) {
  const f = ctx.createBiquadFilter();
  f.type = type;
  f.frequency.value = freq;
  if (q !== undefined) f.Q.value = q;
  return f;
}

function teardownChain(side) {
  if (side === 'h' && hCtx) {
    try { hCtx.close(); } catch (e) { /* ok */ }
    hCtx = null; hChain = null;
  }
  if (side === 'l' && lCtx) {
    try { lCtx.close(); } catch (e) { /* ok */ }
    lCtx = null; lChain = null;
  }
  if (vizRaf) { cancelAnimationFrame(vizRaf); vizRaf = null; vizAn = null; }
}

function applyPreset(p, chain) {
  if (!chain || !p) return;
  // Smoothly transition EQ values
  const now = chain.ctx?.currentTime || 0;
  const ramp = now + 0.05; // 50ms ramp

  chain.sub.gain.linearRampToValueAtTime(p.sub, ramp);
  chain.bass.gain.linearRampToValueAtTime(p.bass, ramp);
  chain.lo.gain.linearRampToValueAtTime(p.lo, ramp);
  chain.mid.gain.linearRampToValueAtTime(p.mid, ramp);
  chain.hi.gain.linearRampToValueAtTime(p.hi, ramp);
  chain.pres.gain.linearRampToValueAtTime(p.pres, ramp);
  chain.air.gain.linearRampToValueAtTime(p.air, ramp);

  chain.comp.ratio.linearRampToValueAtTime(p.ratio, ramp);
  chain.comp.threshold.linearRampToValueAtTime(p.thresh, ramp);
  chain.comp.knee.linearRampToValueAtTime(p.knee, ramp);

  chain.revGain.gain.linearRampToValueAtTime(p.rev, ramp);
  chain.dryGain.gain.linearRampToValueAtTime(1 - (p.rev * 0.5), ramp);
}

function applyPresetByName(name, side) {
  const p = PRESETS[name]; if (!p) return;
  const chain = side === 'h' ? hChain : lChain;
  applyPreset(p, chain);
  currentEQ[side] = name;

  // Update spatial depth indicator
  const sf = G(side + '-spatial-fill');
  const sv = G(side + '-spatial-val');
  if (sf) sf.style.width = (p.depth || 0) + '%';
  if (sv) sv.textContent = (p.depth || 0) + '%';
}

function manualEQ(btn, side) {
  // Disable auto-EQ when user manually selects
  autoEQ[side] = false;
  G(side + '-auto-eq').classList.remove('active');

  const preset = btn.id.replace(/^[hl]eq-/, '');
  applyPresetByName(preset, side);

  document.querySelectorAll('[id^="' + side + 'eq-"]').forEach(b => b.classList.remove('on', 'ai-selected'));
  btn.classList.add('on');

  toast('‚ú¶ ' + (PRESETS[preset]?.label || preset) + ' mode activated');
}

function toggleAutoEQ(side) {
  autoEQ[side] = !autoEQ[side];
  G(side + '-auto-eq').classList.toggle('active', autoEQ[side]);
  toast(autoEQ[side] ? 'üß† AI Auto-EQ enabled' : 'üéõ Manual EQ mode');
}

// ‚îÄ‚îÄ‚îÄ VOLUME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setVol(side, v) {
  const val = parseFloat(v);
  const audio = G(side + '-audio');
  if (audio) audio.volume = val;
  const chain = side === 'h' ? hChain : lChain;
  if (chain) {
    const now = chain.ctx?.currentTime || 0;
    chain.master.gain.linearRampToValueAtTime(val, now + 0.02);
  }
  G(side + '-vol-val').textContent = Math.round(val * 100) + '%';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SOCKET.IO CONNECTION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function initSock() {
  if (sock && sock.connected) return;

  sock = io({
    transports: ['websocket', 'polling'],
    reconnectionAttempts: 30,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    timeout: 20000,
    forceNew: false,
  });

  sock.on('connect', () => {
    console.log('[WS] Connected:', sock.id);
    setConn(true);
    doNTP();
    clearInterval(window._ka);
    window._ka = setInterval(() => { if (sock?.connected) sock.emit('keepalive'); }, 15000);
  });

  sock.on('disconnect', reason => {
    console.warn('[WS] Disconnected:', reason);
    setConn(false);
    if (roomCode) toast('‚ö†Ô∏è Reconnecting...');
  });

  sock.on('reconnect', () => {
    setConn(true);
    toast('‚úÖ Reconnected!');
    doNTP();
  });

  sock.on('connect_error', e => {
    console.error('[WS] Error:', e.message);
    setConn(false);
  });

  // NTP response handler
  sock.on('ntp:pong', ({ clientTime, serverTime }) => {
    const now = Date.now();
    const rtt = now - clientTime;
    const offset = now - (serverTime + rtt / 2);
    ntpSamples.push({ rtt, offset });

    if (ntpSamples.length < NTP_ROUNDS) {
      setTimeout(() => sock.emit('ntp:ping', { clientTime: Date.now() }), 30);
    } else {
      finishNTP();
    }
  });

  // ‚îÄ‚îÄ HOST events ‚îÄ‚îÄ
  sock.on('room:listener_joined', ({ id, count }) => {
    listeners[id] = { t: Date.now() };
    renderListeners();
    // Re-send current track state to new listener
    if (currentTrack && !currentTrack.isLocal) {
      const a = G('h-audio');
      setTimeout(() => {
        sock.emit('track:set', {
          streamUrl: currentTrack.streamUrl,
          title: currentTrack.title,
          originalUrl: currentTrack.originalUrl,
        });
        setTimeout(() => {
          if (a && !a.paused) {
            sock.emit('audio:play', { position: a.currentTime, serverPlayAt: srvNow() + SCHED_MS });
          }
        }, 500);
      }, 300);
    }
  });

  sock.on('room:listener_left', ({ id }) => {
    delete listeners[id];
    renderListeners();
  });

  sock.on('room:count', n => G('h-lcnt').textContent = n);

  // ‚îÄ‚îÄ LISTENER events ‚îÄ‚îÄ
  sock.on('track:set', ({ streamUrl, title }) => {
    loadListenerTrack(streamUrl, title);
  });

  sock.on('audio:play', ({ position, serverPlayAt }) => {
    schedPlay(position, serverPlayAt);
  });

  sock.on('audio:pause', ({ position }) => {
    cancelSched();
    clearInterval(driftWatcher);
    const a = G('l-audio');
    if (!a.src) return;
    a.pause();
    if (isFinite(position) && Math.abs(a.currentTime - position) > 0.5) {
      a.currentTime = position;
    }
    G('l-art').classList.remove('spinning');
    setPill('l-pill', 'pw', 'dm', 'Paused by Host');
    setSyncInfo('Host paused playback.');
  });

  sock.on('audio:seek', ({ position, playing, serverPlayAt }) => {
    cancelSched();
    const a = G('l-audio');
    if (!a.src) return;
    a.currentTime = position;
    if (playing) schedPlay(position, serverPlayAt);
    else { a.pause(); G('l-art').classList.remove('spinning'); }
  });

  sock.on('ai:state', ({ genre, mood, preset, confidence }) => {
    // Update listener AI display
    if (G('l-ai-genre')) G('l-ai-genre').textContent = genre ? genre.charAt(0).toUpperCase() + genre.slice(1) : '‚Äî';
    if (G('l-ai-mood')) G('l-ai-mood').textContent = mood ? mood.charAt(0).toUpperCase() + mood.slice(1) : '‚Äî';
    if (G('l-ai-conf')) G('l-ai-conf').textContent = confidence ? (confidence * 100).toFixed(0) + '%' : '‚Äî';
    G('l-ai-info').classList.add('on');
    G('l-ai-pill').style.display = 'inline-flex';

    // Auto-apply host's AI preset if listener has auto-EQ on
    if (autoEQ.l && preset && PRESETS[preset]) {
      applyPresetByName(preset, 'l');
      document.querySelectorAll('[id^="leq-"]').forEach(b => b.classList.remove('on', 'ai-selected'));
      const btn = G('leq-' + preset);
      if (btn) btn.classList.add('on', 'ai-selected');
    }
  });

  sock.on('room:host_left', () => {
    toast('üö™ Host ended the session');
    setTimeout(leave, 1500);
  });
}

// ‚îÄ‚îÄ‚îÄ NTP WITH KALMAN FILTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function doNTP() {
  ntpSamples = [];
  ntpDone = false;
  kalmanOffset = { x: 0, p: 1000, q: 0.5, r: 50 };
  sock.emit('ntp:ping', { clientTime: Date.now() });
}

function kalmanUpdate(measurement) {
  // Prediction
  kalmanOffset.p += kalmanOffset.q;
  // Update
  const k = kalmanOffset.p / (kalmanOffset.p + kalmanOffset.r);
  kalmanOffset.x += k * (measurement - kalmanOffset.x);
  kalmanOffset.p *= (1 - k);
  return kalmanOffset.x;
}

function finishNTP() {
  // Sort by RTT, use best samples
  ntpSamples.sort((a, b) => a.rtt - b.rtt);
  const best = ntpSamples.slice(0, Math.ceil(NTP_ROUNDS / 3));
  bestRTT = ntpSamples[0].rtt;

  // Run Kalman filter over best samples
  for (const sample of best) {
    kalmanUpdate(sample.offset);
  }
  clockOffset = kalmanOffset.x;

  ntpDone = true;

  if (G('l-offset-val')) G('l-offset-val').textContent = Math.round(Math.abs(clockOffset)) + 'ms';
  if (G('l-rtt-val')) G('l-rtt-val').textContent = bestRTT + 'ms';

  console.log(`[NTP] Kalman offset=${clockOffset.toFixed(1)}ms RTT=${bestRTT}ms (${ntpSamples.length} samples)`);
}

// ‚îÄ‚îÄ‚îÄ SCHEDULED PLAY (PID drift correction) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function schedPlay(position, serverPlayAt) {
  cancelSched();
  const a = G('l-audio');
  if (!a || !a.src) { setSyncInfo('‚ö†Ô∏è Track not loaded yet...'); return; }

  const localPlayAt = serverPlayAt + clockOffset;
  const msLeft = localPlayAt - Date.now();

  function execute() {
    const late = Math.max(0, (Date.now() - localPlayAt)) / 1000;
    const target = Math.max(0, position + late);
    const drift = Math.abs(a.currentTime - target);

    if (drift > DRIFT_SOFT) {
      a.currentTime = target;
      driftCorrections++;
    }

    const playPromise = a.play();

    if (playPromise) {
      playPromise.then(() => {
        G('l-art').classList.add('spinning');
        setPill('l-pill', 'ps', 'dc', '‚óè In Sync');
        setSyncInfo('üéß Playing in sync');
        G('unlock').classList.add('gone');
        G('l-latency').style.display = 'flex';
        if (G('l-drift-val')) G('l-drift-val').textContent = Math.round(drift * 1000) + 'ms';
        if (G('l-corrections')) G('l-corrections').textContent = driftCorrections;

        // Build audio chain if not yet built
        if (!lCtx || !lChain) {
          buildChain(a, 'l');
          startAI('l');
        }
        if (lCtx && lCtx.state === 'suspended') lCtx.resume();

        startProg(a, 'l');
        startViz('l-viz');

        // PID-based drift correction loop
        clearInterval(driftWatcher);
        let integralErr = 0;
        let lastErr = 0;
        const Kp = 0.5, Ki = 0.01, Kd = 0.1;

        driftWatcher = setInterval(() => {
          if (a.paused) return;

          const elapsed = (srvNow() - serverPlayAt) / 1000;
          const expected = position + elapsed;
          const error = a.currentTime - expected;
          const absError = Math.abs(error);

          // PID controller
          integralErr += error;
          integralErr = Math.max(-5, Math.min(5, integralErr)); // anti-windup
          const derivative = error - lastErr;
          lastErr = error;

          if (absError > DRIFT_HARD) {
            // Hard correction
            console.warn(`[SYNC] Hard correction: ${absError.toFixed(3)}s`);
            a.currentTime = expected;
            driftCorrections++;
            integralErr = 0;
          } else if (absError > DRIFT_SOFT) {
            // Gentle PID correction via playback rate
            const correction = Kp * error + Ki * integralErr + Kd * derivative;
            const rate = Math.max(0.95, Math.min(1.05, 1 - correction * 0.1));
            a.playbackRate = rate;

            // Reset rate after correction window
            setTimeout(() => { if (!a.paused) a.playbackRate = 1.0; }, 500);
            driftCorrections++;
          } else {
            a.playbackRate = 1.0;
          }

          if (G('l-drift-val')) G('l-drift-val').textContent = Math.round(absError * 1000) + 'ms';
          if (G('l-corrections')) G('l-corrections').textContent = driftCorrections;
        }, 2000);

      }).catch(e => {
        console.warn('[PLAY] Blocked:', e.message);
        // Show unlock overlay
        G('unlock').classList.remove('gone');
        setPill('l-pill', 'pw', 'dm', 'Tap to play');
        setSyncInfo('‚ö†Ô∏è Tap the screen to enable audio');
      });
    }
  }

  if (msLeft > 20) {
    a.currentTime = Math.max(0, position);
    setPill('l-pill', 'pw', 'dm', 'Syncing...');
    setSyncInfo('<span class="spin">‚ü≥</span> Synchronizing playback...');
    pendingPlay = setTimeout(execute, msLeft);
  } else {
    execute();
  }
}

function cancelSched() {
  if (pendingPlay) { clearTimeout(pendingPlay); pendingPlay = null; }
}

// ‚îÄ‚îÄ‚îÄ CREATE / JOIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createRoom() {
  const name = G('rname-input').value.trim() || 'Audio Room';
  initSock();
  amHost = true;

  function go() {
    sock.emit('room:create', { name }, res => {
      if (!res || !res.ok) { toast('‚ùå Could not create room'); return; }
      roomCode = res.code;
      G('h-rname').textContent = res.name;
      G('h-code').textContent = res.code;
      show('s-host');
      toast('üéâ Room created! Share: ' + res.code);
    });
  }

  if (sock.connected) go();
  else { toast('Connecting...'); sock.once('connect', () => setTimeout(go, 200)); }
}

function joinRoom() {
  const code = G('join-code').value.trim().toUpperCase();
  if (code.length < 6) { toast('Enter the full 6-letter code'); return; }

  G('join-err').classList.remove('on');
  G('join-err').textContent = '';
  initSock();
  amHost = false;

  function go() {
    sock.emit('room:join', { code }, res => {
      if (!res || !res.ok) {
        G('join-err').textContent = res?.error || 'Room not found. Check the code.';
        G('join-err').classList.add('on');
        return;
      }
      roomCode = code;
      G('l-rname').textContent = res.name;
      G('l-clabel').textContent = 'Room: ' + code;
      show('s-listen');
      toast('üéß Joined! Syncing...');

      if (res.track && res.track.streamUrl) {
        loadListenerTrack(res.track.streamUrl, res.track.title, () => {
          if (res.state && res.state.playing && res.state.serverPlayAt) {
            const elapsed = (srvNow() - res.state.serverPlayAt) / 1000;
            const pos = Math.max(0, (res.state.position || 0) + elapsed);
            schedPlay(pos, srvNow() + SCHED_MS);
          } else if (res.state) {
            const a = G('l-audio');
            a.currentTime = res.state.position || 0;
            setSyncInfo('Track loaded. Waiting for host to play.');
          }
        });
      }

      // Apply host's AI state if available
      if (res.aiState && res.aiState.genre) {
        sock.emit('ai:state', res.aiState); // will trigger our own handler
      }
    });
  }

  if (sock.connected) go();
  else { toast('Connecting...'); sock.once('connect', () => setTimeout(go, 300)); }
}

// ‚îÄ‚îÄ‚îÄ LISTENER TRACK LOAD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadListenerTrack(url, title, cb) {
  const a = G('l-audio');
  teardownChain('l');
  stopAI();

  // Reset completely
  a.pause();
  a.removeAttribute('src');
  a.load();

  a.src = url;
  a.crossOrigin = 'anonymous';
  a.preload = 'auto';
  a.load();

  G('l-tname').textContent = title || 'Loading...';
  setSyncInfo('<span class="spin">‚ü≥</span> Loading track...');
  setPill('l-pill', 'pw', 'dm', 'Loading...');

  let ready = false;

  function onReady() {
    if (ready) return;
    ready = true;
    a.removeEventListener('canplay', onReady);
    a.removeEventListener('loadeddata', onReady);

    if (a.duration && isFinite(a.duration)) G('l-dur').textContent = fmt(a.duration);
    setSyncInfo('‚úÖ Ready ‚Äî waiting for host to play...');
    setPill('l-pill', 'pw', 'dm', 'Ready');

    buildChain(a, 'l');
    startAI('l');

    if (cb) cb();
  }

  function onErr() {
    a.removeEventListener('error', onErr);
    const c = a.error ? a.error.code : 0;
    const msgs = ['', 'Aborted', 'Network error', 'Decode error', 'Not supported'];
    const msg = msgs[c] || 'Load failed';

    // Retry once for network errors
    if (c === 2 && !a._retried) {
      a._retried = true;
      setSyncInfo('<span class="spin">‚ü≥</span> Retrying...');
      setTimeout(() => {
        a.load();
        a.addEventListener('canplay', onReady, { once: true });
        a.addEventListener('error', () => {
          setSyncInfo('‚ùå ' + msg);
          toast('‚ùå Track load failed', 4000);
        }, { once: true });
      }, 2000);
      return;
    }

    setSyncInfo('‚ùå ' + msg);
    toast('‚ùå Track load failed: ' + msg, 4000);
  }

  a.addEventListener('canplay', onReady, { once: true });
  a.addEventListener('loadeddata', onReady, { once: true });
  a.addEventListener('error', onErr, { once: true });

  // Buffer progress
  a.addEventListener('progress', () => {
    if (a.buffered.length > 0 && isFinite(a.duration)) {
      const pct = (a.buffered.end(a.buffered.length - 1) / a.duration) * 100;
      const buf = G('l-buffer');
      if (buf) buf.style.width = pct + '%';
    }
  });
}

// ‚îÄ‚îÄ‚îÄ HOST CONTROLS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hostPlay() {
  const a = G('h-audio');
  if (!a.src) { toast('Load a track first'); return; }
  if (hCtx && hCtx.state === 'suspended') hCtx.resume();

  const pos = a.currentTime;
  const playAt = srvNow() + SCHED_MS;

  setTimeout(() => {
    a.play().then(() => {
      G('h-art').classList.add('spinning');
    }).catch(e => {
      console.warn('[HOST PLAY]', e);
      G('unlock').classList.remove('gone');
    });
  }, SCHED_MS);

  setPill('h-pill', 'pl', 'dg', '‚óè Playing');
  sock.emit('audio:play', { position: pos, serverPlayAt: playAt });
  startViz('h-viz');
}

function hostPause() {
  const a = G('h-audio');
  a.pause();
  G('h-art').classList.remove('spinning');
  setPill('h-pill', 'pw', 'dm', 'Paused');
  sock.emit('audio:pause', { position: a.currentTime });
}

function hostRestart() {
  const a = G('h-audio');
  if (!a.src) return;
  if (hCtx && hCtx.state === 'suspended') hCtx.resume();

  a.currentTime = 0;
  const playAt = srvNow() + SCHED_MS;

  setTimeout(() => {
    a.play().then(() => G('h-art').classList.add('spinning')).catch(() => {});
  }, SCHED_MS);

  setPill('h-pill', 'pl', 'dg', '‚óè Playing');
  sock.emit('audio:play', { position: 0, serverPlayAt: playAt });
}

// ‚îÄ‚îÄ‚îÄ LEAVE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function leave() {
  cancelSched();
  stopAI();
  clearInterval(window._ka);
  clearInterval(driftWatcher);
  if (progRaf) { cancelAnimationFrame(progRaf); progRaf = null; }
  if (vizRaf) { cancelAnimationFrame(vizRaf); vizRaf = null; }

  ['h-audio', 'l-audio'].forEach(id => {
    const a = G(id);
    if (a) { a.pause(); a.removeAttribute('src'); a.load(); }
  });

  teardownChain('h');
  teardownChain('l');

  if (sock) { sock.disconnect(); sock = null; }
  roomCode = null;
  listeners = {};
  currentTrack = null;
  driftCorrections = 0;
  autoEQ = { h: false, l: false };

  setConn(false);
  show('s-home');
}

// ‚îÄ‚îÄ‚îÄ UI HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function copyCode() {
  const code = G('h-code').textContent;
  if (navigator.clipboard) {
    navigator.clipboard.writeText(code).then(() => toast('üìã Copied: ' + code));
  } else {
    const el = document.createElement('textarea');
    el.value = code; el.style.position = 'fixed'; el.style.opacity = '0';
    document.body.appendChild(el); el.select();
    document.execCommand('copy');
    document.body.removeChild(el);
    toast('üìã Copied: ' + code);
  }
}

function renderListeners() {
  const ids = Object.keys(listeners);
  G('h-lcnt').textContent = ids.length;
  const el = G('h-llist');
  if (!ids.length) {
    el.innerHTML = '<div class="nol">No one joined yet ‚Äî share your code!</div>';
    return;
  }
  el.innerHTML = ids.map((id, i) =>
    '<div class="litem">' +
    '<div class="lav">üéß</div>' +
    '<span>Listener ' + (i + 1) + '</span>' +
    '<span style="margin-left:auto;font-family:\'Space Mono\',monospace;font-size:9px;color:var(--g)">‚óè synced</span>' +
    '</div>'
  ).join('');
}

function startProg(audio, side) {
  if (progRaf) { cancelAnimationFrame(progRaf); progRaf = null; }

  const fillId = side + '-fill';
  const curId = side + '-cur';
  const durId = side + '-dur';

  function tick() {
    progRaf = requestAnimationFrame(tick);
    if (!audio.duration || !isFinite(audio.duration)) return;

    const p = (audio.currentTime / audio.duration) * 100;
    const f = G(fillId); if (f) f.style.width = p + '%';
    const c = G(curId); if (c) c.textContent = fmt(audio.currentTime);
    const d = G(durId); if (d) d.textContent = fmt(audio.duration);
  }
  tick();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NEURAL VISUALIZER
//  FFT frequency spectrum with:
//  - Gradient bars with frequency-mapped colors
//  - Peak hold indicators with decay
//  - Beat pulse glow effect
//  - Waveform overlay
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function startViz(canvasId) {
  if (vizRaf) { cancelAnimationFrame(vizRaf); vizRaf = null; }
  if (!vizAn) return;

  const cv = G(canvasId);
  if (!cv) return;

  const dpr = window.devicePixelRatio || 1;
  const W = cv.offsetWidth || 760;
  const H = cv.offsetHeight || 68;
  cv.width = W * dpr;
  cv.height = H * dpr;
  const ctx = cv.getContext('2d');
  ctx.scale(dpr, dpr);

  const bins = vizAn.frequencyBinCount;
  const freqBuf = new Uint8Array(bins);
  const timeBuf = new Float32Array(vizAn.fftSize);
  const peaks = new Float32Array(bins);
  const peakDecay = 0.985;
  const barCount = Math.min(bins, Math.floor(W / 3));
  const barWidth = (W / barCount) * 0.85;
  const barGap = (W / barCount) * 0.15;
  let beatGlow = 0;
  let lastEnergy = 0;

  function draw() {
    vizRaf = requestAnimationFrame(draw);
    vizAn.getByteFrequencyData(freqBuf);
    vizAn.getFloatTimeDomainData(timeBuf);

    // Background
    ctx.fillStyle = '#06070c';
    ctx.fillRect(0, 0, W, H);

    // Beat detection for glow effect
    let energy = 0;
    for (let i = 0; i < barCount; i++) energy += freqBuf[i];
    energy /= barCount;
    if (energy > lastEnergy * 1.25 && energy > 80) beatGlow = 1;
    else beatGlow *= 0.92;
    lastEnergy = energy;

    // Beat glow background
    if (beatGlow > 0.1) {
      const grd = ctx.createRadialGradient(W/2, H, 0, W/2, H, W * 0.6);
      grd.addColorStop(0, `rgba(0, 229, 255, ${beatGlow * 0.08})`);
      grd.addColorStop(1, 'transparent');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);
    }

    // Frequency bars
    let x = 0;
    for (let i = 0; i < barCount; i++) {
      const idx = Math.floor(i * bins / barCount);
      const r = freqBuf[idx] / 255;
      const h = r * H * 0.88;

      if (r > peaks[i]) peaks[i] = r;
      else peaks[i] *= peakDecay;

      // Color based on frequency
      const hue = 175 + (i / barCount) * 100;
      const sat = 80 + r * 20;
      const light = 50 + r * 15;
      const alpha = 0.6 + r * 0.4;

      // Bar gradient
      const grad = ctx.createLinearGradient(x, H, x, H - h);
      grad.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`);
      grad.addColorStop(1, `hsla(${hue + 20}, ${sat}%, ${light + 15}%, ${alpha * 0.6})`);
      ctx.fillStyle = grad;

      // Rounded bars
      const bh = Math.max(1, h);
      const radius = Math.min(barWidth / 2, 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, H);
      ctx.lineTo(x + radius, H - bh + radius);
      ctx.arc(x + radius, H - bh + radius, radius, Math.PI, Math.PI * 1.5);
      ctx.lineTo(x + barWidth - radius, H - bh);
      ctx.arc(x + barWidth - radius, H - bh + radius, radius, -Math.PI / 2, 0);
      ctx.lineTo(x + barWidth, H);
      ctx.fill();

      // Peak hold line
      if (peaks[i] > 0.06) {
        const py = H - peaks[i] * H * 0.88;
        ctx.fillStyle = `hsla(${hue}, 100%, 85%, ${0.5 + peaks[i] * 0.3})`;
        ctx.fillRect(x, py - 1, barWidth, 1.5);
      }

      x += barWidth + barGap;
    }

    // Subtle waveform overlay
    ctx.strokeStyle = 'rgba(139, 92, 246, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    const sliceWidth = W / timeBuf.length;
    let wx = 0;
    for (let i = 0; i < timeBuf.length; i++) {
      const v = timeBuf[i] * 0.5 + 0.5;
      const y = v * H;
      if (i === 0) ctx.moveTo(wx, y);
      else ctx.lineTo(wx, y);
      wx += sliceWidth;
    }
    ctx.stroke();
  }

  draw();
}

// ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
G('join-code').addEventListener('input', function() {
  this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
});

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.addEventListener('load', () => {
  setupUnlock();
  initSock();

  G('join-code').addEventListener('keydown', e => { if (e.key === 'Enter') joinRoom(); });
  G('rname-input').addEventListener('keydown', e => { if (e.key === 'Enter') createRoom(); });
  G('yt-url').addEventListener('keydown', e => { if (e.key === 'Enter') loadYoutube(); });
  G('direct-url').addEventListener('keydown', e => { if (e.key === 'Enter') loadDirectUrl(); });

  // Paste handler for YouTube URL
  G('yt-url').addEventListener('paste', () => {
    setTimeout(() => {
      const val = G('yt-url').value.trim();
      if (val && (val.includes('youtube.com') || val.includes('youtu.be'))) {
        // Auto-load after paste
        setTimeout(loadYoutube, 300);
      }
    }, 100);
  });

  console.log('%cüåä WaveRoom v3.0 ‚Äî Neural AI Spatial Audio', 'color:#00e5ff;font-size:14px;font-weight:bold');
  console.log('%c‚ú¶ Neural genre detection\n‚ú¶ PID drift correction\n‚ú¶ Kalman NTP sync\n‚ú¶ Real-time spectral analysis', 'color:#ffd700;font-size:10px');
});

// Visibility change handler ‚Äî resume audio context when tab becomes active
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) {
    [hCtx, lCtx].forEach(c => { if (c && c.state === 'suspended') c.resume(); });
  }
});
</script>
</body>
</html>
